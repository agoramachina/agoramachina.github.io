<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaldao Fractal Visualizer - Complete</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            color: #fff; 
            font-family: 'Courier New', monospace; 
            overflow: hidden; 
            touch-action: none; /* Prevent default touch behaviors */
            user-select: none; /* Prevent text selection on mobile */
        }
        #canvas { display: block; }
        .ui { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            background: rgba(0,0,0,0.8); 
            padding: 15px; 
            border-radius: 8px; 
            font-size: 14px; 
            max-width: 400px; 
            transition: opacity 0.3s ease;
        }
        .controls { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            background: rgba(0,0,0,0.8); 
            padding: 15px; 
            border-radius: 8px; 
            font-size: 12px; 
            transition: opacity 0.3s ease; 
        }
        .menu { 
            display: none; /* Hide menu completely */
        }
        .menu h2 { color: #4CAF50; margin-bottom: 20px; text-align: center; }
        .menu .section { margin-bottom: 15px; }
        .menu .section h3 { color: #FFC107; margin-bottom: 8px; }
        .hidden { opacity: 0; pointer-events: none; }
        .error { color: #ff4444; }
        .success { color: #44ff44; }

        /* Mobile-specific styles */
        @media (max-width: 768px) {
            .ui { 
                top: 10px; 
                left: 10px; 
                right: 10px; 
                max-width: none; 
                font-size: 12px; 
                padding: 10px; 
            }
            .controls { 
                top: 10px; 
                right: 10px; 
                font-size: 10px; 
                padding: 8px; 
                max-width: 150px; 
            }
            .menu { 
                top: 5%; 
                left: 5%; 
                right: 5%; 
                bottom: 5%; 
                transform: none; 
                max-width: none; 
                max-height: none; 
                width: 90%; 
                height: 90%; 
                padding: 15px; 
            }
            .menu h2 { font-size: 16px; margin-bottom: 15px; }
            .menu .section h3 { font-size: 14px; }
        }

        /* Touch indicator overlay */
        .touch-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            text-align: center;
            z-index: 500;
            transition: opacity 0.3s ease;
        }

        /* Touch zone visual feedback - removed since we're not using tap zones anymore */

        @media (max-width: 768px) {
            .touch-indicator {
                bottom: 10px;
                font-size: 11px;
                padding: 8px 12px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls" id="controls">
        <strong>CONTROLS</strong><br>
        <span class="desktop-controls">
        ‚Üê/‚Üí Switch parameter<br>
        ‚Üë/‚Üì Adjust parameter<br>
        C Randomize colors<br>
        Shift+C Reset to B&W<br>
        R Reset current<br>
        Shift+R Reset all<br>
        . Randomize parameters<br>
        I Invert colors<br>
        Space Pause<br>
        S Save parameters<br>
        L Load parameters<br>
        A Upload audio file<br>
        M Toggle microphone<br>
        Ctrl+Z Undo<br>
        Ctrl+Y Redo<br>
        ESC Toggle all parameters<br>
        </span>
        <span class="mobile-controls" style="display: none;">
        SWIPE ‚Üê/‚Üí: Switch parameters<br>
        SWIPE ‚Üë/‚Üì: Adjust value (fader)<br>
        HOLD: Reset all parameters<br>
        SHAKE: Randomize all parameters<br>
        </span>
    </div>

    <!-- Touch indicator for mobile -->
    <div class="touch-indicator" id="touchIndicator" style="display: none;">
        üëÜ Swipe to control ‚Ä¢ Hold to reset ‚Ä¢ Shake to randomize
    </div>

    <!-- All Parameters Display -->
    <div class="menu hidden" id="menu">
        <div style="display: flex; gap: 20px; width: 100%;">
            <div style="flex: 1; min-width: 300px;">
                <h2 style="color: #4CAF50; margin-bottom: 15px; font-size: 18px;">üìä All Parameters</h2>
                <div id="allParametersList" style="font-family: monospace; font-size: 12px; line-height: 1.3;"></div>
            </div>
            
            <div style="flex: 1; min-width: 300px;">
                <h2 style="color: #FFC107; margin-bottom: 15px; font-size: 18px;">üé® Color & Audio</h2>
                
                <div style="margin-bottom: 15px;">
                    <h3 style="color: #FFC107; margin-bottom: 8px; font-size: 14px;">Color Palettes</h3>
                    <div id="allPalettesList" style="font-family: monospace; font-size: 12px; line-height: 1.3;"></div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <h3 style="color: #FFC107; margin-bottom: 8px; font-size: 14px;">Audio Status</h3>
                    <div id="allAudioStatus" style="font-family: monospace; font-size: 12px; line-height: 1.3;"></div>
                </div>
                
                <div>
                    <h3 style="color: #FFC107; margin-bottom: 8px; font-size: 14px;">Quick Controls</h3>
                    <div style="font-size: 11px; line-height: 1.2;">
                        <strong>Navigation:</strong> ‚Üê/‚Üí switch ‚Ä¢ ‚Üë/‚Üì adjust<br>
                        <strong>Randomize:</strong> C colors ‚Ä¢ . parameters<br>
                        <strong>Reset:</strong> R current ‚Ä¢ Shift+R all<br>
                        <strong>Audio:</strong> A upload ‚Ä¢ M microphone<br>
                        <strong>Files:</strong> S save ‚Ä¢ L load<br>
                        <strong>Undo:</strong> Ctrl+Z/Y ‚Ä¢ Space pause<br>
                        <strong>Colors:</strong> I invert ‚Ä¢ Shift+C reset<br>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 15px; opacity: 0.7; font-size: 12px;">
            Press ESC to close ‚Ä¢ Current parameter highlighted in green
        </div>
    </div>

    <script>
        // Global variables
        let gl, canvas, program;
        let animationPaused = false;
        let currentParameterIndex = 0;
        let currentPaletteIndex = 0;
        let useColorPalette = false;
        let invertColors = false;
        let menuVisible = false;
        
        // Controls menu auto-fade system
        let controlsVisible = true;
        let controlsFadeTimeout = null;
        let uiVisible = false;
        let uiFadeTimeout = null;
        const CONTROLS_FADE_DELAY = 3000; // 3 seconds
        const UI_FADE_DELAY = 2000; // 2 seconds for parameter display
        
        // Mobile detection
        let isMobile = false;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        let isTouch = false;
        let touchStartTime = 0;
        let holdTimeout = null;
        const SWIPE_THRESHOLD = 30; // minimum distance for swipe
        const HOLD_DURATION = 800; // ms to trigger hold action
        const FADER_SENSITIVITY = 3; // pixels per adjustment step
        
        // Shake detection
        let lastShakeTime = 0;
        let shakeThreshold = 15; // acceleration threshold
        let lastAcceleration = { x: 0, y: 0, z: 0 };
        const SHAKE_COOLDOWN = 1000; // ms between shakes
        
        // Audio system
        let audioContext = null;
        let audioSource = null;
        let analyser = null;
        let audioData = null;
        let audioElement = null;
        let audioReactive = false;
        let audioPlaying = false;
        let baseParameterValues = {};
        
        // Microphone system
        let microphoneStream = null;
        let microphoneSource = null;
        let microphoneActive = false;

        // Undo/Redo system
        let undoStack = [];
        let redoStack = [];
        const maxUndoSteps = 50;

        // Parameters - exact match to Godot
        const parameters = {
            fly_speed: { value: 0.25, min: -3.0, max: 3.0, step: 0.1, name: "Fly Speed" },
            contrast: { value: 1.0, min: 0.1, max: 5.0, step: 0.1, name: "Contrast" },
            kaleidoscope_segments: { value: 10.0, min: 4.0, max: 300.0, step: 2.0, name: "Kaleidoscope Segments" },
            truchet_radius: { value: 0.35, min: -1.0, max: 1.0, step: 0.01, name: "Truchet Radius" },
            center_fill_radius: { value: 0.0, min: -2.0, max: 2.0, step: 0.01, name: "Center Fill Radius" },
            layer_count: { value: 6, min: 1, max: 50, step: 1, name: "Layer Count" },
            rotation_speed: { value: 0.025, min: -6.0, max: 6.0, step: 0.01, name: "Rotation Speed" },
            zoom_level: { value: 0.3, min: -5.0, max: 5.0, step: 0.05, name: "Zoom Level" },
            color_intensity: { value: 1.0, min: 0.1, max: 2.0, step: 0.1, name: "Color Intensity" },
            plane_rotation_speed: { value: 0.5, min: -5.0, max: 5.0, step: 0.1, name: "Plane Rotation Speed" },
            camera_tilt_x: { value: 0.0, min: -10.0, max: 10.0, step: 1.0, name: "Camera Tilt X" },
            camera_tilt_y: { value: 0.0, min: -10.0, max: 10.0, step: 1.0, name: "Camera Tilt Y" },
            camera_roll: { value: 0.0, min: -3.14, max: 3.14, step: 0.1, name: "Camera Roll" },
            path_stability: { value: 1.0, min: -1.0, max: 1.0, step: 0.05, name: "Path Stability" },
            path_scale: { value: 1.0, min: -3.0, max: 3.0, step: 0.1, name: "Path Scale" },
            color_speed: { value: 0.5, min: 0.0, max: 2.0, step: 0.1, name: "Color Speed" }
        };

        // Time accumulation
        const timeAccumulation = {
            camera_position: 0.0,
            rotation_time: 0.0,
            plane_rotation_time: 0.0,
            color_time: 0.0
        };

        // Color palettes
        const colorPalettes = [
            { name: "B&W", a: [0.5, 0.5, 0.5], b: [0.5, 0.5, 0.5], c: [1.0, 1.0, 1.0], d: [0.0, 0.0, 0.0] },
            { name: "Rainbow", a: [0.5, 0.5, 0.5], b: [0.5, 0.5, 0.5], c: [1.0, 1.0, 1.0], d: [0.0, 0.33, 0.67] },
            { name: "Fire", a: [0.5, 0.2, 0.1], b: [0.5, 0.3, 0.2], c: [2.0, 1.0, 0.5], d: [0.0, 0.25, 0.5] },
            { name: "Ocean", a: [0.2, 0.5, 0.8], b: [0.2, 0.3, 0.5], c: [1.0, 1.5, 2.0], d: [0.0, 0.2, 0.5] },
            { name: "Purple", a: [0.8, 0.5, 0.4], b: [0.2, 0.4, 0.2], c: [2.0, 1.0, 1.0], d: [0.0, 0.25, 0.25] },
            { name: "Neon", a: [0.2, 0.2, 0.2], b: [0.8, 0.8, 0.8], c: [1.0, 2.0, 1.5], d: [0.0, 0.5, 0.8] },
            { name: "Sunset", a: [0.7, 0.3, 0.2], b: [0.3, 0.2, 0.1], c: [1.5, 1.0, 0.8], d: [0.0, 0.1, 0.3] }
        ];

        // Parameter keys in the order they appear in the menu display
        const parameterKeys = [
            // MOVEMENT & ANIMATION
            'fly_speed', 'rotation_speed', 'plane_rotation_speed', 'zoom_level',
            // PATTERN & VISUAL  
            'kaleidoscope_segments', 'truchet_radius', 'center_fill_radius', 'layer_count', 'contrast', 'color_intensity',
            // CAMERA & PATH
            'camera_tilt_x', 'camera_tilt_y', 'camera_roll', 'path_stability', 'path_scale',
            // COLOR & SPEED
            'color_speed'
        ];

        // Shaders
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_camera_position;
            uniform float u_rotation_time;
            uniform float u_plane_rotation_time;
            uniform float u_color_time;
            uniform float u_fly_speed;
            uniform float u_contrast;
            uniform float u_kaleidoscope_segments;
            uniform float u_layer_count;
            uniform float u_truchet_radius;
            uniform float u_center_fill_radius;
            uniform float u_rotation_speed;
            uniform float u_plane_rotation_speed;
            uniform float u_zoom_level;
            uniform float u_color_intensity;
            uniform float u_camera_tilt_x;
            uniform float u_camera_tilt_y;
            uniform float u_camera_roll;
            uniform float u_path_stability;
            uniform float u_path_scale;
            uniform float u_use_color_palette;
            uniform float u_invert_colors;
            uniform float u_color_speed;
            uniform vec3 u_palette_a;
            uniform vec3 u_palette_b;
            uniform vec3 u_palette_c;
            uniform vec3 u_palette_d;
            
            #define PI 3.14159265359
            
            mat2 ROT(float a) {
                return mat2(cos(a), sin(a), -sin(a), cos(a));
            }
            
            float hashf(float co) {
                return fract(sin(co * 12.9898) * 13758.5453);
            }
            
            float hashv(vec2 p) {
                float a = dot(p, vec2(127.1, 311.7));
                return fract(sin(a) * 43758.5453123);
            }
            
            float tanh_approx(float x) {
                float x2 = x * x;
                return clamp(x * (27.0 + x2) / (27.0 + 9.0 * x2), -1.0, 1.0);
            }
            
            float pmin(float a, float b, float k) {
                float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
                return mix(b, a, h) - k * h * (1.0 - h);
            }
            
            float pmax(float a, float b, float k) {
                return -pmin(-a, -b, k);
            }
            
            float pabs(float a, float k) {
                return pmax(a, -a, k);
            }
            
            vec2 toPolar(vec2 p) {
                return vec2(length(p), atan(p.y, p.x));
            }
            
            vec2 toRect(vec2 p) {
                return vec2(p.x * cos(p.y), p.x * sin(p.y));
            }
            
            vec3 palette(float t) {
                return u_palette_a + u_palette_b * cos(6.28318 * (u_palette_c * t + u_palette_d));
            }
            
            vec3 offset(float z) {
                float a = z;
                vec2 curved_path = -0.075 * u_path_scale * (
                    vec2(cos(a), sin(a * sqrt(2.0))) +
                    vec2(cos(a * sqrt(0.75)), sin(a * sqrt(0.5)))
                );
                
                vec2 straight_path = vec2(0.0);
                
                vec2 p;
                if (u_path_stability >= 0.0) {
                    p = mix(curved_path, straight_path, u_path_stability);
                } else {
                    p = curved_path * (1.0 + abs(u_path_stability) * 2.0);
                }
                
                p += vec2(u_camera_tilt_x, u_camera_tilt_y) * z * 0.1 * u_path_scale;
                
                return vec3(p, z);
            }
            
            vec3 doffset(float z) {
                float eps = 0.1;
                return 0.5 * (offset(z + eps) - offset(z - eps)) / eps;
            }
            
            vec3 ddoffset(float z) {
                float eps = 0.1;
                return 0.125 * (doffset(z + eps) - doffset(z - eps)) / eps;
            }
            
            float modMirror1(inout float p, float size) {
                float halfsize = size * 0.5;
                float c = floor((p + halfsize) / size);
                p = mod(p + halfsize, size) - halfsize;
                p *= mod(c, 2.0) * 2.0 - 1.0;
                return c;
            }
            
            float smoothKaleidoscope(inout vec2 p, float sm, float rep) {
                vec2 hp = p;
                vec2 hpp = toPolar(hp);
                
                float rn = modMirror1(hpp.y, 2.0 * PI / rep);
                
                float sa = PI / rep - pabs(PI / rep - abs(hpp.y), sm);
                hpp.y = sign(hpp.y) * sa;
                
                hp = toRect(hpp);
                p = hp;
                
                return rn;
            }
            
            vec3 cell_df(float r, vec2 np, vec2 mp, vec2 off) {
                vec2 n0 = normalize(vec2(1.0, 1.0));
                vec2 n1 = normalize(vec2(1.0, -1.0));
                
                np += off;
                mp -= off;
                
                float hh = hashv(np);
                float h0 = hh;
                
                vec2 p0 = mp;
                p0 = abs(p0);
                p0 -= 0.5;
                float d0 = length(p0);
                float d1 = abs(d0 - r);
                
                float dot0 = dot(n0, mp);
                float dot1 = dot(n1, mp);
                
                float d2 = abs(dot0);
                float t2 = dot1;
                d2 = abs(t2) > sqrt(0.5) ? d0 : d2;
                
                float d3 = abs(dot1);
                float t3 = dot0;
                d3 = abs(t3) > sqrt(0.5) ? d0 : d3;
                
                float d = d0;
                d = min(d, d1);
                
                if (h0 > 0.85) {
                    d = min(d, d2);
                    d = min(d, d3);
                } else if (h0 > 0.5) {
                    d = min(d, d2);
                } else if (h0 > 0.15) {
                    d = min(d, d3);
                }
                
                float center_circle_factor = length(mp) <= r ? 1.0 : 0.0;
                return vec3(d, (d0 - r), center_circle_factor);
            }
            
            vec3 truchet_df(float r, vec2 p) {
                vec2 np = floor(p + 0.5);
                vec2 mp = fract(p + 0.5) - 0.5;
                return cell_df(r, np, mp, vec2(0.0));
            }
            
            vec4 alphaBlend(vec4 back, vec4 front) {
                float w = front.w + back.w * (1.0 - front.w);
                vec3 xyz = (front.xyz * front.w + back.xyz * back.w * (1.0 - front.w)) / w;
                return w > 0.0 ? vec4(xyz, w) : vec4(0.0);
            }
            
            vec3 alphaBlend34(vec3 back, vec4 front) {
                return mix(back, front.xyz, front.w);
            }
            
            vec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {
                float h_ = hashf(n);
                float h0 = fract(1777.0 * h_);
                float h1 = fract(2087.0 * h_);
                float h4 = fract(3499.0 * h_);
                
                float l = length(pp - ro);
                
                vec2 p = (pp - off * vec3(1.0, 1.0, 0.0)).xy;
                vec2 original_p = p;
                
                p = ROT(u_plane_rotation_time * (h4 - 0.5)) * p;
                
                float rep = u_kaleidoscope_segments;
                float sm = 0.05 * 20.0 / rep;
                float sn = smoothKaleidoscope(p, sm, rep);
                
                p = ROT(2.0 * PI * h0 + u_rotation_time) * p;
                
                float z = u_zoom_level;
                p /= z;
                p += 0.5 + floor(h1 * 1000.0);
                
                float tl = tanh_approx(0.33 * l);
                float r = u_truchet_radius;
                vec3 d3 = truchet_df(r, p);
                d3.xy *= z;
                float d = d3.x;
                float lw = 0.025 * z;
                d -= lw;
                
                vec3 col = mix(vec3(1.0), vec3(0.0), smoothstep(aa, -aa, d));
                col = mix(col, vec3(0.0), smoothstep(mix(1.0, -0.5, tl), 1.0, sin(PI * 100.0 * d)));
                
                float center_distance = length(original_p);
                float center_edge = smoothstep(u_center_fill_radius + aa, u_center_fill_radius - aa, center_distance);
                float transparency = 0.99;
                col = mix(col, vec3(0.0), center_edge * (u_center_fill_radius > 0.01 ? 1.0 : 0.0) * transparency);
                
                float t = smoothstep(aa, -aa, -d3.y - 3.0 * lw) *
                         mix(0.5, 1.0, smoothstep(aa, -aa, -d3.y - lw));
                
                col = mix(col, vec3(0.01), d3.y <= 0.0 ? 1.0 : 0.0);
                
                return vec4(col, t);
            }
            
            vec3 skyColor(vec3 ro, vec3 rd) {
                float d = pow(max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0), 20.0);
                return vec3(d);
            }
            
            vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {
                float lp = length(p);
                vec2 np = p + 1.0 / (u_resolution * u_contrast);
                float rdd = (2.0 + 1.0 * tanh_approx(lp));
                
                vec3 rd = normalize(p.x * uu + p.y * vv + rdd * ww);
                vec3 nrd = normalize(np.x * uu + np.y * vv + rdd * ww);
                
                float planeDist = 1.0 - 0.25;
                float furthest = u_layer_count;
                float fadeFrom = max(furthest - 5.0, 0.0);
                
                float nz = floor(ro.z / planeDist);
                
                vec3 skyCol = skyColor(ro, rd);
                
                vec4 acol = vec4(0.0);
                float cutOff = 0.95;
                
                for (float i = 1.0; i <= 10.0; i += 1.0) {
                    if (i > furthest) break;
                    
                    float pz = planeDist * nz + planeDist * i;
                    float pd = (pz - ro.z) / rd.z;
                    
                    if (pd > 0.0 && acol.w < cutOff) {
                        vec3 pp = ro + rd * pd;
                        vec3 npp = ro + nrd * pd;
                        
                        float aa = 3.0 * length(pp - npp);
                        vec3 off = offset(pp.z);
                        
                        vec4 pcol = plane(ro, rd, pp, off, aa, nz + i);
                        
                        float nz1 = pp.z - ro.z;
                        float fadeIn = smoothstep(planeDist * furthest, planeDist * fadeFrom, nz1);
                        float fadeOut = smoothstep(0.0, planeDist * 0.1, nz1);
                        
                        pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);
                        pcol.w *= fadeOut;
                        pcol = clamp(pcol, 0.0, 1.0);
                        
                        acol = alphaBlend(pcol, acol);
                    }
                }
                
                vec3 col = alphaBlend34(skyCol, acol);
                return col;
            }
            
            vec3 effect(vec2 p, vec2 q) {
                vec3 ro = offset(u_camera_position);
                vec3 dro = doffset(u_camera_position);
                vec3 ddro = ddoffset(u_camera_position);
                
                vec3 ww = normalize(dro);
                vec3 uu = normalize(cross(
                    normalize(vec3(0.0, 1.0, 0.0) + ddro),
                    ww
                ));
                vec3 vv = normalize(cross(ww, uu));
                
                if (abs(u_camera_roll) > 0.001) {
                    mat2 roll_rot = ROT(u_camera_roll);
                    p = roll_rot * p;
                }
                
                vec3 col = color(ww, uu, vv, ro, p);
                
                return col;
            }
            
            vec3 postProcess(vec3 col, vec2 q) {
                if (u_use_color_palette > 0.5) {
                    float t = length(col) + u_color_time;
                    col = palette(t) * length(col);
                }
                
                col = clamp(col, 0.0, 1.0);
                col = pow(col, vec3(1.0 / 2.2));
                col = col * 0.6 + 0.4 * col * col * (3.0 - 2.0 * col);
                col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);
                
                col *= 0.5 + 0.5 * pow(19.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7);
                col *= u_color_intensity;
                
                if (u_invert_colors > 0.5) {
                    col = vec3(1.0) - col;
                }
                
                return col;
            }
            
            void main() {
                vec2 q = gl_FragCoord.xy / u_resolution.xy;
                vec2 p = -1.0 + 2.0 * q;
                p.x *= u_resolution.x / u_resolution.y;
                
                vec3 col = effect(p, q);
                col = postProcess(col, q);
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // Uniform locations
        let uniforms = {};

        function init() {
            try {
                canvas = document.getElementById('canvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                // Detect mobile
                detectMobile();
                
                gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                if (!gl) throw new Error('WebGL not supported');
                
                setupShaders();
                setupGeometry();
                setupUniforms();
                setupControls();
                setupTouchControls();
                
                updateStatus('‚úÖ Kaldao loaded successfully!', 'success');
                updateDisplay();
                
                // Start controls auto-fade timer
                showControls();
                
                // Initially hide the UI panel
                hideUI();
                
                render();
                
            } catch (error) {
                updateStatus(`‚ùå Error: ${error.message}`, 'error');
                console.error(error);
            }
        }

        function detectMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
            
            if (isMobile) {
                // Show mobile controls, hide desktop controls
                const mobileControls = document.querySelector('.mobile-controls');
                const desktopControls = document.querySelector('.desktop-controls');
                
                if (mobileControls) mobileControls.style.display = 'block';
                if (desktopControls) desktopControls.style.display = 'none';
            }
        }

        function setupTouchControls() {
            if (!isMobile) return;
            
            // Touch event listeners
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Prevent default touch behaviors
            canvas.addEventListener('touchstart', (e) => e.preventDefault());
            canvas.addEventListener('touchmove', (e) => e.preventDefault());
            
            // Shake detection
            setupShakeDetection();
        }

        function setupShakeDetection() {
            if (!isMobile || !window.DeviceMotionEvent) return;
            
            // Request permission for iOS 13+
            if (typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                    .then(response => {
                        if (response == 'granted') {
                            window.addEventListener('devicemotion', handleDeviceMotion);
                        }
                    })
                    .catch(console.error);
            } else {
                // Non-iOS or older iOS
                window.addEventListener('devicemotion', handleDeviceMotion);
            }
        }

        function handleDeviceMotion(event) {
            if (!isMobile) return;
            
            const acceleration = event.accelerationIncludingGravity;
            if (!acceleration) return;
            
            const now = Date.now();
            if (now - lastShakeTime < SHAKE_COOLDOWN) return;
            
            // Calculate total acceleration change
            const deltaX = Math.abs(acceleration.x - lastAcceleration.x);
            const deltaY = Math.abs(acceleration.y - lastAcceleration.y);
            const deltaZ = Math.abs(acceleration.z - lastAcceleration.z);
            const totalDelta = deltaX + deltaY + deltaZ;
            
            if (totalDelta > shakeThreshold) {
                lastShakeTime = now;
                randomizeParameters();
                updateStatus('üé≤ Shake detected - randomized!', 'success');
                showUI(); // Show parameter info after randomizing
            }
            
            lastAcceleration = {
                x: acceleration.x,
                y: acceleration.y,
                z: acceleration.z
            };
        }

        function handleTouchStart(e) {
            if (!isMobile) return;
            
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
            isTouch = true;
            
            // Start hold timer
            holdTimeout = setTimeout(() => {
                if (isTouch) {
                    // Trigger hold action - reset all parameters
                    resetAllParameters();
                    updateStatus('üîÑ Hold detected - all parameters reset!', 'success');
                    
                    // Show visual feedback
                    const indicator = document.getElementById('touchIndicator');
                    if (indicator) {
                        indicator.style.opacity = '1';
                        indicator.textContent = 'üîÑ All Parameters Reset!';
                        setTimeout(() => {
                            indicator.textContent = 'üëÜ Tap to toggle menu ‚Ä¢ Swipe to control ‚Ä¢ Hold to reset ‚Ä¢ Shake to randomize';
                            indicator.style.opacity = '0.7';
                        }, 2000);
                    }
                    
                    // Prevent other actions
                    isTouch = false;
                }
            }, HOLD_DURATION);
            
            // Show controls on touch
            resetControlsFadeTimer();
        }

        function handleTouchMove(e) {
            if (!isMobile || !isTouch) return;
            
            const touch = e.touches[0];
            touchEndX = touch.clientX;
            touchEndY = touch.clientY;
            
            // Check if we've moved enough to be considered a swipe/fader
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);
            
            // If we're moving, cancel the hold timer
            if ((absDeltaX > 10 || absDeltaY > 10) && holdTimeout) {
                clearTimeout(holdTimeout);
                holdTimeout = null;
            }
            
            // Implement fader for vertical movement
            if (absDeltaY > absDeltaX && absDeltaY > FADER_SENSITIVITY) {
                const steps = Math.floor(absDeltaY / FADER_SENSITIVITY);
                const direction = deltaY < 0 ? 1 : -1; // up = increase, down = decrease
                
                // Apply adjustment
                adjustParameter(direction * steps * 0.1); // Smaller steps for smooth fading
                showUI(); // Show parameter info while adjusting
                
                // Reset start position for continuous fading
                touchStartY = touchEndY;
            }
        }

        function handleTouchEnd(e) {
            if (!isMobile) return;
            
            // Clear hold timer
            if (holdTimeout) {
                clearTimeout(holdTimeout);
                holdTimeout = null;
            }
            
            if (!isTouch) return;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);
            const touchDuration = Date.now() - touchStartTime;
            
            // Determine action based on gesture
            if (absDeltaX < SWIPE_THRESHOLD && absDeltaY < SWIPE_THRESHOLD && touchDuration < HOLD_DURATION) {
                // Quick tap - no action (menu removed)
            } else if (absDeltaX > absDeltaY && absDeltaX > SWIPE_THRESHOLD) {
                // Horizontal swipe - switch parameters
                if (deltaX > 0) {
                    switchParameter(1); // Swipe right
                } else {
                    switchParameter(-1); // Swipe left
                }
            }
            // Vertical swipes are handled continuously in handleTouchMove for fader behavior
            
            isTouch = false;
            touchStartX = 0;
            touchStartY = 0;
            touchEndX = 0;
            touchEndY = 0;
            touchStartTime = 0;
        }

        function setupShaders() {
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
            program = createProgram(vertexShader, fragmentShader);
        }

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const error = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                throw new Error(`Shader compilation failed: ${error}`);
            }
            return shader;
        }

        function createProgram(vertexShader, fragmentShader) {
            const prog = gl.createProgram();
            gl.attachShader(prog, vertexShader);
            gl.attachShader(prog, fragmentShader);
            gl.linkProgram(prog);
            
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                const error = gl.getProgramInfoLog(prog);
                gl.deleteProgram(prog);
                throw new Error(`Program linking failed: ${error}`);
            }
            return prog;
        }

        function setupGeometry() {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 1, -1, -1, 1, 1, 1
            ]), gl.STATIC_DRAW);
            
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        }

        function setupUniforms() {
            const uniformNames = [
                'u_resolution', 'u_time', 'u_camera_position', 'u_rotation_time',
                'u_plane_rotation_time', 'u_color_time', 'u_fly_speed', 'u_contrast',
                'u_kaleidoscope_segments', 'u_layer_count', 'u_truchet_radius',
                'u_center_fill_radius', 'u_rotation_speed', 'u_plane_rotation_speed',
                'u_zoom_level', 'u_color_intensity', 'u_camera_tilt_x', 'u_camera_tilt_y',
                'u_camera_roll', 'u_path_stability', 'u_path_scale', 'u_use_color_palette',
                'u_invert_colors', 'u_color_speed', 'u_palette_a', 'u_palette_b',
                'u_palette_c', 'u_palette_d'
            ];
            
            uniformNames.forEach(name => {
                uniforms[name] = gl.getUniformLocation(program, name);
            });
        }

        // Controls auto-fade functions
        function showControls() {
            const controls = document.getElementById('controls');
            if (controls && !menuVisible) {
                controls.classList.remove('hidden');
                controlsVisible = true;
                
                // Clear existing timeout
                if (controlsFadeTimeout) {
                    clearTimeout(controlsFadeTimeout);
                }
                
                // Set new timeout to hide controls
                controlsFadeTimeout = setTimeout(() => {
                    hideControls();
                }, CONTROLS_FADE_DELAY);
            }
        }
        
        function hideControls() {
            const controls = document.getElementById('controls');
            if (controls && !menuVisible) {
                controls.classList.add('hidden');
                controlsVisible = false;
            }
        }

        // UI parameter display functions
        function showUI() {
            const ui = document.getElementById('ui');
            if (ui) {
                ui.classList.remove('hidden');
                uiVisible = true;
                
                // Clear existing timeout
                if (uiFadeTimeout) {
                    clearTimeout(uiFadeTimeout);
                }
                
                // Set new timeout to hide UI
                uiFadeTimeout = setTimeout(() => {
                    hideUI();
                }, UI_FADE_DELAY);
            }
        }
        
        function hideUI() {
            const ui = document.getElementById('ui');
            if (ui) {
                ui.classList.add('hidden');
                uiVisible = false;
            }
        }
        
        function resetControlsFadeTimer() {
            if (!menuVisible) {
                showControls();
            }
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => {
                try {
                    // Reset controls fade timer on any keypress
                    resetControlsFadeTimer();
                    
                    switch(e.code) {
                        case 'ArrowUp':
                            e.preventDefault();
                            if (menuVisible) {
                                // In ESC menu: up/down switches parameters (original behavior)
                                switchParameter(-1);
                            } else {
                                // In normal view: up/down adjusts values
                                adjustParameter(1);
                                showUI(); // Show parameter info when adjusting
                            }
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            if (menuVisible) {
                                // In ESC menu: up/down switches parameters (original behavior)
                                switchParameter(1);
                            } else {
                                // In normal view: up/down adjusts values
                                adjustParameter(-1);
                                showUI(); // Show parameter info when adjusting
                            }
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            if (menuVisible) {
                                // In ESC menu: left/right adjusts parameters (original behavior)
                                adjustParameter(-1);
                            } else {
                                // In normal view: left/right cycles through parameters
                                switchParameter(-1);
                            }
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            if (menuVisible) {
                                // In ESC menu: left/right adjusts parameters (original behavior)
                                adjustParameter(1);
                            } else {
                                // In normal view: left/right cycles through parameters
                                switchParameter(1);
                            }
                            break;
                        case 'Space':
                            e.preventDefault();
                            animationPaused = !animationPaused;
                            updateStatus(`Animation: ${animationPaused ? 'PAUSED' : 'RUNNING'}`, 'info');
                            break;
                        case 'KeyC':
                            e.preventDefault();
                            if (e.shiftKey) {
                                resetToBlackWhite();
                            } else {
                                randomizeColors();
                            }
                            break;
                        case 'KeyR':
                            e.preventDefault();
                            if (e.shiftKey) {
                                if (confirm('Reset all parameters?')) {
                                    resetAllParameters();
                                }
                            } else {
                                resetCurrentParameter();
                            }
                            break;
                        case 'Period':
                            e.preventDefault();
                            randomizeParameters();
                            break;
                        case 'KeyI':
                            e.preventDefault();
                            toggleInvertColors();
                            break;
                        case 'KeyS':
                            e.preventDefault();
                            saveParameters();
                            break;
                        case 'KeyL':
                            e.preventDefault();
                            loadParameters();
                            break;
                        case 'Escape':
                            e.preventDefault();
                            // ESC functionality removed - no menu to toggle
                            break;
                        case 'KeyA':
                            e.preventDefault();
                            toggleAudio();
                            break;
                        case 'KeyZ':
                            e.preventDefault();
                            if (e.ctrlKey || e.metaKey) {
                                undo();
                            }
                            break;
                        case 'KeyY':
                            e.preventDefault();
                            if (e.ctrlKey || e.metaKey) {
                                redo();
                            }
                            break;
                        case 'KeyM':
                            e.preventDefault();
                            toggleMicrophone();
                            break;
                    }
                } catch (error) {
                    updateStatus(`Input error: ${error.message}`, 'error');
                }
            });

            window.addEventListener('resize', () => {
                if (canvas && gl) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    
                    // Re-detect mobile on resize
                    detectMobile();
                }
            });

            // Add orientation change handler for mobile
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    if (canvas && gl) {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                        gl.viewport(0, 0, canvas.width, canvas.height);
                        detectMobile();
                    }
                }, 100);
            });
        }

        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            if (statusDiv) {
                statusDiv.className = type;
                statusDiv.textContent = message;
            }
        }

        function updateDisplay() {
            const paramKey = parameterKeys[currentParameterIndex];
            const param = parameters[paramKey];
            const palette = colorPalettes[currentPaletteIndex];
            
            const paramDiv = document.getElementById('currentParam');
            if (paramDiv) {
                paramDiv.textContent = `${param.name}: ${param.value.toFixed(3)} | ${palette.name}${invertColors ? ' (Inverted)' : ''}`;
            }
        }

        function adjustParameter(delta) {
            const paramKey = parameterKeys[currentParameterIndex];
            const param = parameters[paramKey];
            
            param.value = Math.max(param.min, Math.min(param.max, param.value + delta * param.step));
            
            if (paramKey === 'kaleidoscope_segments') {
                param.value = Math.round(param.value / 2) * 2;
            }
            
            updateDisplay();
            
            // Show UI when adjusting parameters
            showUI();
        }

        function switchParameter(delta) {
            currentParameterIndex = (currentParameterIndex + delta + parameterKeys.length) % parameterKeys.length;
            updateDisplay();
            
            // Show UI when switching parameters
            showUI();
        }

        function randomizeColors() {
            const palette = colorPalettes[currentPaletteIndex];
            for (let i = 0; i < 3; i++) {
                palette.a[i] = Math.random();
                palette.b[i] = Math.random();
                palette.c[i] = Math.random() * 2.0;
                palette.d[i] = Math.random();
            }
            
            if (currentPaletteIndex === 0) {
                currentPaletteIndex = 1;
                useColorPalette = true;
            }
            
            updateDisplay();
            showUI(); // Show UI when randomizing colors
        }

        function resetToBlackWhite() {
            currentPaletteIndex = 0;
            useColorPalette = false;
            invertColors = false;
            updateDisplay();
            showUI(); // Show UI when resetting colors
        }

        function toggleInvertColors() {
            invertColors = !invertColors;
            updateDisplay();
            showUI(); // Show UI when inverting colors
        }

        function randomizeParameters() {
            const excludeParams = ['color_intensity', 'color_speed'];
            
            Object.keys(parameters).forEach(key => {
                if (excludeParams.includes(key)) return;
                
                const param = parameters[key];
                param.value = Math.random() * (param.max - param.min) + param.min;
                param.value = Math.round(param.value / param.step) * param.step;
                
                if (key === 'kaleidoscope_segments') {
                    param.value = Math.round(param.value / 2) * 2;
                }
                
                param.value = Math.max(param.min, Math.min(param.max, param.value));
            });
            
            updateDisplay();
            showUI(); // Show UI when randomizing parameters
        }

        function resetCurrentParameter() {
            const paramKey = parameterKeys[currentParameterIndex];
            const param = parameters[paramKey];
            
            const defaults = {
                fly_speed: 0.25, contrast: 1.0, kaleidoscope_segments: 10.0,
                truchet_radius: 0.35, center_fill_radius: 0.0, layer_count: 6,
                rotation_speed: 0.025, zoom_level: 0.3, color_intensity: 1.0,
                plane_rotation_speed: 0.5, camera_tilt_x: 0.0, camera_tilt_y: 0.0,
                camera_roll: 0.0, path_stability: 1.0, path_scale: 1.0, color_speed: 0.5
            };
            
            if (defaults[paramKey] !== undefined) {
                param.value = defaults[paramKey];
            }
            
            updateDisplay();
            showUI(); // Show UI when resetting current parameter
        }

        function resetAllParameters() {
            Object.keys(parameters).forEach(key => {
                const defaults = {
                    fly_speed: 0.25, contrast: 1.0, kaleidoscope_segments: 10.0,
                    truchet_radius: 0.35, center_fill_radius: 0.0, layer_count: 6,
                    rotation_speed: 0.025, zoom_level: 0.3, color_intensity: 1.0,
                    plane_rotation_speed: 0.5, camera_tilt_x: 0.0, camera_tilt_y: 0.0,
                    camera_roll: 0.0, path_stability: 1.0, path_scale: 1.0, color_speed: 0.5
                };
                
                if (defaults[key] !== undefined) {
                    parameters[key].value = defaults[key];
                }
            });
            
            currentPaletteIndex = 0;
            useColorPalette = false;
            invertColors = false;
            
            updateDisplay();
            showUI(); // Show UI when resetting all parameters
        }

        function saveStateForUndo() {}
        function undo() { updateStatus('Undo not implemented in this version', 'info'); }
        function redo() { updateStatus('Redo not implemented in this version', 'info'); }
        function restoreState(state) {}

        function toggleMenu() {
            // Menu functionality removed - no menu to toggle
        }

        function updateMenuDisplay() {
            // Menu functionality removed - no menu to update
        }

        function saveParameters() {
            updateStatus('üíæ Save feature not implemented in this version', 'info');
        }

        function loadParameters() {
            updateStatus('üìÅ Load feature not implemented in this version', 'info');
        }

        function toggleAudio() {
            updateStatus('üéµ Audio features not implemented in this version', 'info');
        }

        function toggleMicrophone() {
            updateStatus('üé§ Microphone features not implemented in this version', 'info');
        }

        function render() {
            try {
                const deltaTime = 1.0 / 60.0;

                if (!animationPaused) {
                    timeAccumulation.camera_position += parameters.fly_speed.value * deltaTime;
                    timeAccumulation.rotation_time += parameters.rotation_speed.value * deltaTime;
                    timeAccumulation.plane_rotation_time += parameters.plane_rotation_speed.value * deltaTime;
                    timeAccumulation.color_time += parameters.color_speed.value * deltaTime;
                }

                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.useProgram(program);
                
                // Set all uniforms
                gl.uniform2f(uniforms.u_resolution, canvas.width, canvas.height);
                gl.uniform1f(uniforms.u_time, performance.now() * 0.001);
                gl.uniform1f(uniforms.u_camera_position, timeAccumulation.camera_position);
                gl.uniform1f(uniforms.u_rotation_time, timeAccumulation.rotation_time);
                gl.uniform1f(uniforms.u_plane_rotation_time, timeAccumulation.plane_rotation_time);
                gl.uniform1f(uniforms.u_color_time, timeAccumulation.color_time);
                gl.uniform1f(uniforms.u_fly_speed, parameters.fly_speed.value);
                gl.uniform1f(uniforms.u_contrast, parameters.contrast.value);
                gl.uniform1f(uniforms.u_kaleidoscope_segments, parameters.kaleidoscope_segments.value);
                gl.uniform1f(uniforms.u_layer_count, parameters.layer_count.value);
                gl.uniform1f(uniforms.u_truchet_radius, parameters.truchet_radius.value);
                gl.uniform1f(uniforms.u_center_fill_radius, parameters.center_fill_radius.value);
                gl.uniform1f(uniforms.u_rotation_speed, parameters.rotation_speed.value);
                gl.uniform1f(uniforms.u_plane_rotation_speed, parameters.plane_rotation_speed.value);
                gl.uniform1f(uniforms.u_zoom_level, parameters.zoom_level.value);
                gl.uniform1f(uniforms.u_color_intensity, parameters.color_intensity.value);
                gl.uniform1f(uniforms.u_camera_tilt_x, parameters.camera_tilt_x.value);
                gl.uniform1f(uniforms.u_camera_tilt_y, parameters.camera_tilt_y.value);
                gl.uniform1f(uniforms.u_camera_roll, parameters.camera_roll.value);
                gl.uniform1f(uniforms.u_path_stability, parameters.path_stability.value);
                gl.uniform1f(uniforms.u_path_scale, parameters.path_scale.value);
                gl.uniform1f(uniforms.u_color_speed, parameters.color_speed.value);
                gl.uniform1f(uniforms.u_use_color_palette, useColorPalette ? 1.0 : 0.0);
                gl.uniform1f(uniforms.u_invert_colors, invertColors ? 1.0 : 0.0);
                
                const palette = colorPalettes[currentPaletteIndex];
                gl.uniform3f(uniforms.u_palette_a, palette.a[0], palette.a[1], palette.a[2]);
                gl.uniform3f(uniforms.u_palette_b, palette.b[0], palette.b[1], palette.b[2]);
                gl.uniform3f(uniforms.u_palette_c, palette.c[0], palette.c[1], palette.c[2]);
                gl.uniform3f(uniforms.u_palette_d, palette.d[0], palette.d[1], palette.d[2]);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                requestAnimationFrame(render);
            } catch (error) {
                updateStatus(`Render error: ${error.message}`, 'error');
            }
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>