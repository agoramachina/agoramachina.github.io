<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaldao Fractal Visualizer - Complete</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; color: #fff; font-family: 'Courier New', monospace; overflow: hidden; }
        #canvas { display: block; }
        .ui { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; font-size: 14px; max-width: 400px; transition: opacity 0.3s ease; }
        .controls { position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px; font-size: 12px; transition: opacity 0.3s ease; }
        .menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); padding: 20px; border-radius: 12px; border: 2px solid #444; max-width: 95vw; max-height: 90vh; overflow-y: auto; z-index: 1000; }
        .menu h2 { color: #4CAF50; margin-bottom: 20px; text-align: center; }
        .menu .section { margin-bottom: 15px; }
        .menu .section h3 { color: #FFC107; margin-bottom: 8px; }
        .hidden { opacity: 0; pointer-events: none; }
        .error { color: #ff4444; }
        .success { color: #44ff44; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="ui" id="ui">
        <h3>Kaldao Fractal Visualizer</h3>
        <div id="status">Loading...</div>
        <div id="currentParam">Parameter: Loading...</div>
    </div>
    
    <div class="controls" id="controls">
        <strong>CONTROLS</strong><br>
        ‚Üë/‚Üì Switch parameter<br>
        ‚Üê/‚Üí Adjust parameter<br>
        C Randomize colors<br>
        Shift+C Reset to B&W<br>
        R Reset current<br>
        Shift+R Reset all<br>
        . Randomize parameters<br>
        I Invert colors<br>
        Space Pause<br>
        S Save parameters<br>
        L Load parameters<br>
        A Upload audio file<br>
        M Toggle microphone<br>
        Ctrl+Z Undo<br>
        Ctrl+Y Redo<br>
        ESC Toggle all parameters<br>
    </div>

    <!-- All Parameters Display -->
    <div class="menu hidden" id="menu">
        <div style="display: flex; gap: 20px; width: 100%;">
            <div style="flex: 1; min-width: 300px;">
                <h2 style="color: #4CAF50; margin-bottom: 15px; font-size: 18px;">üìä All Parameters</h2>
                <div id="allParametersList" style="font-family: monospace; font-size: 12px; line-height: 1.3;"></div>
            </div>
            
            <div style="flex: 1; min-width: 300px;">
                <h2 style="color: #FFC107; margin-bottom: 15px; font-size: 18px;">üé® Color & Audio</h2>
                
                <div style="margin-bottom: 15px;">
                    <h3 style="color: #FFC107; margin-bottom: 8px; font-size: 14px;">Color Palettes</h3>
                    <div id="allPalettesList" style="font-family: monospace; font-size: 12px; line-height: 1.3;"></div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <h3 style="color: #FFC107; margin-bottom: 8px; font-size: 14px;">Audio Status</h3>
                    <div id="allAudioStatus" style="font-family: monospace; font-size: 12px; line-height: 1.3;"></div>
                </div>
                
                <div>
                    <h3 style="color: #FFC107; margin-bottom: 8px; font-size: 14px;">Quick Controls</h3>
                    <div style="font-size: 11px; line-height: 1.2;">
                        <strong>Navigation:</strong> ‚Üë/‚Üì switch ‚Ä¢ ‚Üê/‚Üí adjust<br>
                        <strong>Randomize:</strong> C colors ‚Ä¢ . parameters<br>
                        <strong>Reset:</strong> R current ‚Ä¢ Shift+R all<br>
                        <strong>Audio:</strong> A upload ‚Ä¢ M microphone<br>
                        <strong>Files:</strong> S save ‚Ä¢ L load<br>
                        <strong>Undo:</strong> Ctrl+Z/Y ‚Ä¢ Space pause<br>
                        <strong>Colors:</strong> I invert ‚Ä¢ Shift+C reset<br>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 15px; opacity: 0.7; font-size: 12px;">
            Press ESC to close ‚Ä¢ Current parameter highlighted in green
        </div>
    </div>

    <script>
        // Global variables
        let gl, canvas, program;
        let animationPaused = false;
        let currentParameterIndex = 0;
        let currentPaletteIndex = 0;
        let useColorPalette = false;
        let invertColors = false;
        let menuVisible = false;
        
        // State persistence
        let stateLoaded = false;
        let autoSaveTimeout = null;
        const AUTO_SAVE_DELAY = 2000; // Auto-save after 2 seconds of inactivity
        
        // Controls menu auto-fade system
        let controlsVisible = true;
        let controlsFadeTimeout = null;
        const CONTROLS_FADE_DELAY = 3000; // 3 seconds
        
        // Mobile detection and touch handling
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let isLongPress = false;
        let isDragging = false;
        let lastTouchTime = 0;
        
        // Shake detection
        let lastAcceleration = { x: 0, y: 0, z: 0 };
        let shakeThreshold = 25; // Increased from 15 to make it less sensitive
        let shakeTimeout = null;
        
        // Audio system
        let audioContext = null;
        let audioSource = null;
        let analyser = null;
        let audioData = null;
        let audioElement = null;
        let audioReactive = false;
        let audioPlaying = false;
        let baseParameterValues = {};
        
        // Audio modifiers - these multiply the base parameters
        let audioModifiers = {
            fly_speed: 1.0,
            contrast: 1.0,
            kaleidoscope_segments: 1.0,
            truchet_radius: 1.0,
            center_fill_radius: 1.0,
            layer_count: 1.0,
            rotation_speed: 1.0,
            zoom_level: 1.0,
            color_intensity: 1.0,
            plane_rotation_speed: 1.0,
            camera_tilt_x: 1.0,
            camera_tilt_y: 1.0,
            camera_roll: 1.0,
            path_stability: 1.0,
            path_scale: 1.0,
            color_speed: 1.0
        };
        
        // Microphone system
        let microphoneStream = null;
        let microphoneSource = null;
        let microphoneActive = false;

        // Undo/Redo system
        let undoStack = [];
        let redoStack = [];
        const maxUndoSteps = 50;

        // Parameters - exact match to Godot
        const parameters = {
            fly_speed: { value: 0.25, min: -3.0, max: 3.0, step: 0.1, name: "Fly Speed" },
            contrast: { value: 1.0, min: 0.1, max: 5.0, step: 0.1, name: "Contrast" },
            kaleidoscope_segments: { value: 10.0, min: 4.0, max: 80.0, step: 2.0, name: "Kaleidoscope Segments" },
            truchet_radius: { value: 0.35, min: -1.0, max: 1.0, step: 0.01, name: "Truchet Radius" },
            center_fill_radius: { value: 0.0, min: -2.0, max: 2.0, step: 0.01, name: "Center Fill Radius" },
            layer_count: { value: 6, min: 1, max: 10, step: 1, name: "Layer Count" },
            rotation_speed: { value: 0.025, min: -6.0, max: 6.0, step: 0.01, name: "Rotation Speed" },
            zoom_level: { value: 0.3, min: -5.0, max: 5.0, step: 0.05, name: "Zoom Level" },
            color_intensity: { value: 1.0, min: 0.1, max: 2.0, step: 0.1, name: "Color Intensity" },
            plane_rotation_speed: { value: 0.5, min: -5.0, max: 5.0, step: 0.1, name: "Plane Rotation Speed" },
            camera_tilt_x: { value: 0.0, min: -10.0, max: 10.0, step: 1.0, name: "Camera Tilt X" },
            camera_tilt_y: { value: 0.0, min: -10.0, max: 10.0, step: 1.0, name: "Camera Tilt Y" },
            camera_roll: { value: 0.0, min: -3.14, max: 3.14, step: 0.1, name: "Camera Roll" },
            path_stability: { value: 1.0, min: -1.0, max: 1.0, step: 0.05, name: "Path Stability" },
            path_scale: { value: 1.0, min: -3.0, max: 3.0, step: 0.1, name: "Path Scale" },
            color_speed: { value: 0.5, min: 0.0, max: 2.0, step: 0.1, name: "Color Speed" }
        };

        // Time accumulation
        const timeAccumulation = {
            camera_position: 0.0,
            rotation_time: 0.0,
            plane_rotation_time: 0.0,
            color_time: 0.0
        };

        // Color palettes
        const colorPalettes = [
            { name: "B&W", a: [0.5, 0.5, 0.5], b: [0.5, 0.5, 0.5], c: [1.0, 1.0, 1.0], d: [0.0, 0.0, 0.0] },
            { name: "Rainbow", a: [0.5, 0.5, 0.5], b: [0.5, 0.5, 0.5], c: [1.0, 1.0, 1.0], d: [0.0, 0.33, 0.67] },
            { name: "Fire", a: [0.5, 0.2, 0.1], b: [0.5, 0.3, 0.2], c: [2.0, 1.0, 0.5], d: [0.0, 0.25, 0.5] },
            { name: "Ocean", a: [0.2, 0.5, 0.8], b: [0.2, 0.3, 0.5], c: [1.0, 1.5, 2.0], d: [0.0, 0.2, 0.5] },
            { name: "Purple", a: [0.8, 0.5, 0.4], b: [0.2, 0.4, 0.2], c: [2.0, 1.0, 1.0], d: [0.0, 0.25, 0.25] },
            { name: "Neon", a: [0.2, 0.2, 0.2], b: [0.8, 0.8, 0.8], c: [1.0, 2.0, 1.5], d: [0.0, 0.5, 0.8] },
            { name: "Sunset", a: [0.7, 0.3, 0.2], b: [0.3, 0.2, 0.1], c: [1.5, 1.0, 0.8], d: [0.0, 0.1, 0.3] }
        ];

        // Parameter keys in the order they appear in the menu display
        const parameterKeys = [
            // MOVEMENT & ANIMATION
            'fly_speed', 'rotation_speed', 'plane_rotation_speed', 'zoom_level',
            // PATTERN & VISUAL  
            'kaleidoscope_segments', 'truchet_radius', 'center_fill_radius', 'layer_count', 'contrast', 'color_intensity',
            // CAMERA & PATH
            'camera_tilt_x', 'camera_tilt_y', 'camera_roll', 'path_stability', 'path_scale',
            // COLOR & SPEED
            'color_speed'
        ];

        // Shaders
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision highp float;
            
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_camera_position;
            uniform float u_rotation_time;
            uniform float u_plane_rotation_time;
            uniform float u_color_time;
            uniform float u_fly_speed;
            uniform float u_contrast;
            uniform float u_kaleidoscope_segments;
            uniform float u_layer_count;
            uniform float u_truchet_radius;
            uniform float u_center_fill_radius;
            uniform float u_rotation_speed;
            uniform float u_plane_rotation_speed;
            uniform float u_zoom_level;
            uniform float u_color_intensity;
            uniform float u_camera_tilt_x;
            uniform float u_camera_tilt_y;
            uniform float u_camera_roll;
            uniform float u_path_stability;
            uniform float u_path_scale;
            uniform float u_use_color_palette;
            uniform float u_invert_colors;
            uniform float u_color_speed;
            uniform vec3 u_palette_a;
            uniform vec3 u_palette_b;
            uniform vec3 u_palette_c;
            uniform vec3 u_palette_d;
            
            #define PI 3.14159265359
            
            mat2 ROT(float a) {
                return mat2(cos(a), sin(a), -sin(a), cos(a));
            }
            
            float hashf(float co) {
                return fract(sin(co * 12.9898) * 13758.5453);
            }
            
            float hashv(vec2 p) {
                float a = dot(p, vec2(127.1, 311.7));
                return fract(sin(a) * 43758.5453123);
            }
            
            float tanh_approx(float x) {
                float x2 = x * x;
                return clamp(x * (27.0 + x2) / (27.0 + 9.0 * x2), -1.0, 1.0);
            }
            
            float pmin(float a, float b, float k) {
                float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
                return mix(b, a, h) - k * h * (1.0 - h);
            }
            
            float pmax(float a, float b, float k) {
                return -pmin(-a, -b, k);
            }
            
            float pabs(float a, float k) {
                return pmax(a, -a, k);
            }
            
            vec2 toPolar(vec2 p) {
                return vec2(length(p), atan(p.y, p.x));
            }
            
            vec2 toRect(vec2 p) {
                return vec2(p.x * cos(p.y), p.x * sin(p.y));
            }
            
            vec3 palette(float t) {
                return u_palette_a + u_palette_b * cos(6.28318 * (u_palette_c * t + u_palette_d));
            }
            
            vec3 offset(float z) {
                float a = z;
                vec2 curved_path = -0.075 * u_path_scale * (
                    vec2(cos(a), sin(a * sqrt(2.0))) +
                    vec2(cos(a * sqrt(0.75)), sin(a * sqrt(0.5)))
                );
                
                vec2 straight_path = vec2(0.0);
                
                vec2 p;
                if (u_path_stability >= 0.0) {
                    p = mix(curved_path, straight_path, u_path_stability);
                } else {
                    p = curved_path * (1.0 + abs(u_path_stability) * 2.0);
                }
                
                p += vec2(u_camera_tilt_x, u_camera_tilt_y) * z * 0.1 * u_path_scale;
                
                return vec3(p, z);
            }
            
            vec3 doffset(float z) {
                float eps = 0.1;
                return 0.5 * (offset(z + eps) - offset(z - eps)) / eps;
            }
            
            vec3 ddoffset(float z) {
                float eps = 0.1;
                return 0.125 * (doffset(z + eps) - doffset(z - eps)) / eps;
            }
            
            float modMirror1(inout float p, float size) {
                float halfsize = size * 0.5;
                float c = floor((p + halfsize) / size);
                p = mod(p + halfsize, size) - halfsize;
                p *= mod(c, 2.0) * 2.0 - 1.0;
                return c;
            }
            
            float smoothKaleidoscope(inout vec2 p, float sm, float rep) {
                vec2 hp = p;
                vec2 hpp = toPolar(hp);
                
                // Manual rounding: floor(x + 0.5) for smoother transitions
                float evenRep = floor(rep * 0.5 + 0.5) * 2.0;
                evenRep = max(evenRep, 4.0); // Minimum of 4 segments
                
                float rn = modMirror1(hpp.y, 2.0 * PI / evenRep);
                
                float sa = PI / evenRep - pabs(PI / evenRep - abs(hpp.y), sm);
                hpp.y = sign(hpp.y) * sa;
                
                hp = toRect(hpp);
                p = hp;
                
                return rn;
            }
            
            vec3 cell_df(float r, vec2 np, vec2 mp, vec2 off) {
                vec2 n0 = normalize(vec2(1.0, 1.0));
                vec2 n1 = normalize(vec2(1.0, -1.0));
                
                np += off;
                mp -= off;
                
                float hh = hashv(np);
                float h0 = hh;
                
                vec2 p0 = mp;
                p0 = abs(p0);
                p0 -= 0.5;
                float d0 = length(p0);
                float d1 = abs(d0 - r);
                
                float dot0 = dot(n0, mp);
                float dot1 = dot(n1, mp);
                
                float d2 = abs(dot0);
                float t2 = dot1;
                d2 = abs(t2) > sqrt(0.5) ? d0 : d2;
                
                float d3 = abs(dot1);
                float t3 = dot0;
                d3 = abs(t3) > sqrt(0.5) ? d0 : d3;
                
                float d = d0;
                d = min(d, d1);
                
                if (h0 > 0.85) {
                    d = min(d, d2);
                    d = min(d, d3);
                } else if (h0 > 0.5) {
                    d = min(d, d2);
                } else if (h0 > 0.15) {
                    d = min(d, d3);
                }
                
                float center_circle_factor = length(mp) <= r ? 1.0 : 0.0;
                return vec3(d, (d0 - r), center_circle_factor);
            }
            
            vec3 truchet_df(float r, vec2 p) {
                vec2 np = floor(p + 0.5);
                vec2 mp = fract(p + 0.5) - 0.5;
                return cell_df(r, np, mp, vec2(0.0));
            }
            
            vec4 alphaBlend(vec4 back, vec4 front) {
                float w = front.w + back.w * (1.0 - front.w);
                vec3 xyz = (front.xyz * front.w + back.xyz * back.w * (1.0 - front.w)) / w;
                return w > 0.0 ? vec4(xyz, w) : vec4(0.0);
            }
            
            vec3 alphaBlend34(vec3 back, vec4 front) {
                return mix(back, front.xyz, front.w);
            }
            
            vec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 off, float aa, float n) {
                float h_ = hashf(n);
                float h0 = fract(1777.0 * h_);
                float h1 = fract(2087.0 * h_);
                float h4 = fract(3499.0 * h_);
                
                float l = length(pp - ro);
                
                vec2 p = (pp - off * vec3(1.0, 1.0, 0.0)).xy;
                vec2 original_p = p;
                
                p = ROT(u_plane_rotation_time * (h4 - 0.5)) * p;
                
                float rep = u_kaleidoscope_segments;
                float sm = 0.05 * 20.0 / rep;
                float sn = smoothKaleidoscope(p, sm, rep);
                
                p = ROT(2.0 * PI * h0 + u_rotation_time) * p;
                
                float z = u_zoom_level;
                p /= z;
                p += 0.5 + floor(h1 * 1000.0);
                
                float tl = tanh_approx(0.33 * l);
                float r = u_truchet_radius;
                vec3 d3 = truchet_df(r, p);
                d3.xy *= z;
                float d = d3.x;
                float lw = 0.025 * z;
                d -= lw;
                
                vec3 col = mix(vec3(1.0), vec3(0.0), smoothstep(aa, -aa, d));
                col = mix(col, vec3(0.0), smoothstep(mix(1.0, -0.5, tl), 1.0, sin(PI * 100.0 * d)));
                
                float center_distance = length(original_p);
                float center_edge = smoothstep(u_center_fill_radius + aa, u_center_fill_radius - aa, center_distance);
                float transparency = 0.99;
                col = mix(col, vec3(0.0), center_edge * (u_center_fill_radius > 0.01 ? 1.0 : 0.0) * transparency);
                
                float t = smoothstep(aa, -aa, -d3.y - 3.0 * lw) *
                         mix(0.5, 1.0, smoothstep(aa, -aa, -d3.y - lw));
                
                col = mix(col, vec3(0.01), d3.y <= 0.0 ? 1.0 : 0.0);
                
                return vec4(col, t);
            }
            
            vec3 skyColor(vec3 ro, vec3 rd) {
                float d = pow(max(dot(rd, vec3(0.0, 0.0, 1.0)), 0.0), 20.0);
                return vec3(d);
            }
            
            vec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {
                float lp = length(p);
                vec2 np = p + 1.0 / (u_resolution * u_contrast);
                float rdd = (2.0 + 1.0 * tanh_approx(lp));
                
                vec3 rd = normalize(p.x * uu + p.y * vv + rdd * ww);
                vec3 nrd = normalize(np.x * uu + np.y * vv + rdd * ww);
                
                float planeDist = 1.0 - 0.25;
                float furthest = u_layer_count;
                float fadeFrom = max(furthest - 5.0, 0.0);
                
                float nz = floor(ro.z / planeDist);
                
                vec3 skyCol = skyColor(ro, rd);
                
                vec4 acol = vec4(0.0);
                float cutOff = 0.95;
                
                for (float i = 1.0; i <= 10.0; i += 1.0) {
                    if (i > furthest) break;
                    
                    float pz = planeDist * nz + planeDist * i;
                    float pd = (pz - ro.z) / rd.z;
                    
                    if (pd > 0.0 && acol.w < cutOff) {
                        vec3 pp = ro + rd * pd;
                        vec3 npp = ro + nrd * pd;
                        
                        float aa = 3.0 * length(pp - npp);
                        vec3 off = offset(pp.z);
                        
                        vec4 pcol = plane(ro, rd, pp, off, aa, nz + i);
                        
                        float nz1 = pp.z - ro.z;
                        float fadeIn = smoothstep(planeDist * furthest, planeDist * fadeFrom, nz1);
                        float fadeOut = smoothstep(0.0, planeDist * 0.1, nz1);
                        
                        pcol.xyz = mix(skyCol, pcol.xyz, fadeIn);
                        pcol.w *= fadeOut;
                        pcol = clamp(pcol, 0.0, 1.0);
                        
                        acol = alphaBlend(pcol, acol);
                    }
                }
                
                vec3 col = alphaBlend34(skyCol, acol);
                return col;
            }
            
            vec3 effect(vec2 p, vec2 q) {
                vec3 ro = offset(u_camera_position);
                vec3 dro = doffset(u_camera_position);
                vec3 ddro = ddoffset(u_camera_position);
                
                vec3 ww = normalize(dro);
                vec3 uu = normalize(cross(
                    normalize(vec3(0.0, 1.0, 0.0) + ddro),
                    ww
                ));
                vec3 vv = normalize(cross(ww, uu));
                
                if (abs(u_camera_roll) > 0.001) {
                    mat2 roll_rot = ROT(u_camera_roll);
                    p = roll_rot * p;
                }
                
                vec3 col = color(ww, uu, vv, ro, p);
                
                return col;
            }
            
            vec3 postProcess(vec3 col, vec2 q) {
                if (u_use_color_palette > 0.5) {
                    float t = length(col) + u_color_time;
                    col = palette(t) * length(col);
                }
                
                col = clamp(col, 0.0, 1.0);
                col = pow(col, vec3(1.0 / 2.2));
                col = col * 0.6 + 0.4 * col * col * (3.0 - 2.0 * col);
                col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);
                
                col *= 0.5 + 0.5 * pow(19.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7);
                col *= u_color_intensity;
                
                if (u_invert_colors > 0.5) {
                    col = vec3(1.0) - col;
                }
                
                return col;
            }
            
            void main() {
                vec2 q = gl_FragCoord.xy / u_resolution.xy;
                vec2 p = -1.0 + 2.0 * q;
                p.x *= u_resolution.x / u_resolution.y;
                
                vec3 col = effect(p, q);
                col = postProcess(col, q);
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // Uniform locations
        let uniforms = {};

        function init() {
            try {
                canvas = document.getElementById('canvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                if (!gl) throw new Error('WebGL not supported');
                
                setupShaders();
                setupGeometry();
                setupUniforms();
                
                // Load saved state before setting up controls
                loadStateFromStorage();
                
                setupControls();
                
                updateStatus('‚úÖ Kaldao loaded successfully!', 'success');
                updateDisplay();
                // Start controls auto-fade timer
                showControls();
                
                render();
                
            } catch (error) {
                updateStatus(`‚ùå Error: ${error.message}`, 'error');
                console.error(error);
            }
        }

        function setupShaders() {
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
            program = createProgram(vertexShader, fragmentShader);
        }

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const error = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                throw new Error(`Shader compilation failed: ${error}`);
            }
            return shader;
        }

        function createProgram(vertexShader, fragmentShader) {
            const prog = gl.createProgram();
            gl.attachShader(prog, vertexShader);
            gl.attachShader(prog, fragmentShader);
            gl.linkProgram(prog);
            
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                const error = gl.getProgramInfoLog(prog);
                gl.deleteProgram(prog);
                throw new Error(`Program linking failed: ${error}`);
            }
            return prog;
        }

        function setupGeometry() {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                -1, -1, 1, -1, -1, 1, 1, 1
            ]), gl.STATIC_DRAW);
            
            const positionLocation = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        }

        function setupUniforms() {
            const uniformNames = [
                'u_resolution', 'u_time', 'u_camera_position', 'u_rotation_time',
                'u_plane_rotation_time', 'u_color_time', 'u_fly_speed', 'u_contrast',
                'u_kaleidoscope_segments', 'u_layer_count', 'u_truchet_radius',
                'u_center_fill_radius', 'u_rotation_speed', 'u_plane_rotation_speed',
                'u_zoom_level', 'u_color_intensity', 'u_camera_tilt_x', 'u_camera_tilt_y',
                'u_camera_roll', 'u_path_stability', 'u_path_scale', 'u_use_color_palette',
                'u_invert_colors', 'u_color_speed', 'u_palette_a', 'u_palette_b',
                'u_palette_c', 'u_palette_d'
            ];
            
            uniformNames.forEach(name => {
                uniforms[name] = gl.getUniformLocation(program, name);
            });
        }

        // Controls auto-fade functions
        function showControls() {
            const controls = document.getElementById('controls');
            if (controls && !menuVisible) {
                controls.classList.remove('hidden');
                ui.classList.remove('hidden');
                controlsVisible = true;
                
                // Clear existing timeout
                if (controlsFadeTimeout) {
                    clearTimeout(controlsFadeTimeout);
                }
                
                // Set new timeout to hide controls
                controlsFadeTimeout = setTimeout(() => {
                    hideControls();
                }, CONTROLS_FADE_DELAY);
            }
        }
        
        function hideControls() {
            const controls = document.getElementById('controls');
            if (controls && !menuVisible) {
                controls.classList.add('hidden');
                controlsVisible = false;
                ui.classList.add('hidden');
            }
        }
        
        function resetControlsFadeTimer() {
            if (!menuVisible) {
                showControls();
            }
        }

        function setupControls() {
            // Desktop keyboard controls
            document.addEventListener('keydown', (e) => {
                if (isMobile) return; // Skip keyboard on mobile
                
                try {
                    // Reset controls fade timer on any keypress
                    resetControlsFadeTimer();
                    
                    switch(e.code) {
                        case 'ArrowUp':
                            e.preventDefault();
                            switchParameter(-1);
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            switchParameter(1);
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            adjustParameter(-1);
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            adjustParameter(1);
                            break;
                        case 'Space':
                            e.preventDefault();
                            animationPaused = !animationPaused;
                            updateStatus(`Animation: ${animationPaused ? 'PAUSED' : 'RUNNING'}`, 'info');
                            break;
                        case 'KeyC':
                            e.preventDefault();
                            if (e.shiftKey) {
                                resetToBlackWhite();
                            } else {
                                randomizeColors();
                            }
                            break;
                        case 'KeyR':
                            e.preventDefault();
                            if (e.shiftKey) {
                                if (confirm('Reset all parameters?')) {
                                    resetAllParameters();
                                }
                            } else {
                                resetCurrentParameter();
                            }
                            break;
                        case 'Period':
                            e.preventDefault();
                            randomizeParameters();
                            break;
                        case 'KeyI':
                            e.preventDefault();
                            toggleInvertColors();
                            break;
                        case 'KeyS':
                            e.preventDefault();
                            saveParameters();
                            break;
                        case 'KeyL':
                            e.preventDefault();
                            loadParameters();
                            break;
                        case 'Escape':
                            e.preventDefault();
                            toggleMenu();
                            break;
                        case 'KeyA':
                            e.preventDefault();
                            toggleAudio();
                            break;
                        case 'KeyZ':
                            e.preventDefault();
                            if (e.ctrlKey || e.metaKey) {
                                undo();
                            }
                            break;
                        case 'KeyY':
                            e.preventDefault();
                            if (e.ctrlKey || e.metaKey) {
                                redo();
                            }
                            break;
                        case 'KeyM':
                            e.preventDefault();
                            toggleMicrophone();
                            break;
                    }
                } catch (error) {
                    updateStatus(`Input error: ${error.message}`, 'error');
                }
            });

            // Mobile touch controls
            if (isMobile) {
                setupMobileControls();
                
                // Hide desktop controls on mobile
                const controls = document.getElementById('controls');
                if (controls) {
                    controls.style.display = 'none';
                }
                
                // Make UI more mobile friendly
                const ui = document.getElementById('ui');
                if (ui) {
                    ui.style.fontSize = '16px';
                    ui.style.padding = '20px';
                    ui.style.maxWidth = '90vw';
                }
            }

            window.addEventListener('resize', () => {
                if (canvas && gl) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }
            });
        }

        function setupMobileControls() {
            // Touch event listeners
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
            
            // Device motion for shake detection
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', handleDeviceMotion);
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartTime = Date.now();
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            isLongPress = false;
            isDragging = false;
            
            // Start long press timer
            setTimeout(() => {
                if (!isDragging && Date.now() - touchStartTime >= 800) {
                    isLongPress = true;
                    // Vibrate if available
                    if (navigator.vibrate) navigator.vibrate(100);
                    resetAllParameters(); // Changed to reset ALL parameters
                    updateStatus('üì± All parameters reset!', 'success');
                    // Auto-hide status after 2 seconds
                    setTimeout(() => {
                        if (!menuVisible) {
                            const ui = document.getElementById('ui');
                            if (ui) ui.classList.add('hidden');
                        }
                    }, 2000);
                }
            }, 800);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (isLongPress) return;
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > 15) { // Increased threshold for less sensitivity
                isDragging = true;
                
                // Vertical swipe: adjust parameter value (like a fader)
                if (Math.abs(deltaY) > Math.abs(deltaX)) {
                    const sensitivity = 0.003; // Reduced from 0.01 to make it less sensitive
                    const delta = -deltaY * sensitivity; // Invert Y (up = increase)
                    adjustParameterSmooth(delta);
                    
                    // Update start position for continuous dragging
                    touchStartY = touch.clientY;
                }
                // Horizontal swipe: change parameter
                else {
                    const swipeSpeed = Math.abs(deltaX) / (Date.now() - touchStartTime);
                    
                    // Quick swipe: discrete parameter change
                    if (swipeSpeed > 0.5 && Math.abs(deltaX) > 60) {
                        const direction = deltaX > 0 ? 1 : -1;
                        switchParameter(direction);
                        updateStatus(`üì± ${parameters[parameterKeys[currentParameterIndex]].name}`, 'info');
                        
                        // Auto-hide status after 1.5 seconds
                        setTimeout(() => {
                            if (!menuVisible) {
                                const ui = document.getElementById('ui');
                                if (ui) ui.classList.add('hidden');
                            }
                        }, 1500);
                        
                        // Reset touch start to prevent multiple switches
                        touchStartX = touch.clientX;
                        touchStartY = touch.clientY;
                        touchStartTime = Date.now();
                    }
                    // Slow drag: continuous cycling through parameters
                    else if (Math.abs(deltaX) > 40) {
                        const parameterSpacing = 80; // pixels per parameter
                        const parameterIndex = Math.floor(Math.abs(deltaX) / parameterSpacing);
                        const direction = deltaX > 0 ? 1 : -1;
                        const targetIndex = (currentParameterIndex + (direction * parameterIndex) + parameterKeys.length) % parameterKeys.length;
                        
                        if (targetIndex !== currentParameterIndex) {
                            currentParameterIndex = targetIndex;
                            updateDisplay();
                            updateStatus(`üì± ${parameters[parameterKeys[currentParameterIndex]].name}`, 'info');
                            
                            // Auto-hide status after 1.5 seconds
                            setTimeout(() => {
                                if (!menuVisible) {
                                    const ui = document.getElementById('ui');
                                    if (ui) ui.classList.add('hidden');
                                }
                            }, 1500);
                        }
                    }
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            const touchDuration = Date.now() - touchStartTime;
            
            // Simple tap (not long press, not drag)
            if (!isLongPress && !isDragging && touchDuration < 300) {
                // Double tap detection
                const now = Date.now();
                if (now - lastTouchTime < 300) {
                    // Double tap - randomize colors
                    randomizeColors();
                    updateStatus('üì± Colors randomized!', 'success');
                    
                    // Auto-hide status after 2 seconds
                    setTimeout(() => {
                        if (!menuVisible) {
                            const ui = document.getElementById('ui');
                            if (ui) ui.classList.add('hidden');
                        }
                    }, 2000);
                } else {
                    // Single tap - toggle menu
                    toggleMenu();
                }
                lastTouchTime = now;
            }
            
            // Reset touch state
            isLongPress = false;
            isDragging = false;
        }

        function handleDeviceMotion(e) {
            const acceleration = e.accelerationIncludingGravity;
            if (!acceleration) return;
            
            const deltaX = Math.abs(acceleration.x - lastAcceleration.x);
            const deltaY = Math.abs(acceleration.y - lastAcceleration.y);
            const deltaZ = Math.abs(acceleration.z - lastAcceleration.z);
            
            const totalDelta = deltaX + deltaY + deltaZ;
            
            if (totalDelta > shakeThreshold) {
                // Prevent multiple shake detections
                if (!shakeTimeout) {
                    randomizeParameters();
                    updateStatus('üì± Shake detected! Parameters randomized!', 'success');
                    if (navigator.vibrate) navigator.vibrate([50, 100, 50]);
                    
                    // Auto-hide status after 3 seconds
                    setTimeout(() => {
                        if (!menuVisible) {
                            const ui = document.getElementById('ui');
                            if (ui) ui.classList.add('hidden');
                        }
                    }, 3000);
                    
                    shakeTimeout = setTimeout(() => {
                        shakeTimeout = null;
                    }, 1000);
                }
            }
            
            lastAcceleration = { x: acceleration.x, y: acceleration.y, z: acceleration.z };
        }

        function adjustParameterSmooth(delta) {
            // Save current state before making changes
            saveStateForUndo();
            
            const paramKey = parameterKeys[currentParameterIndex];
            const param = parameters[paramKey];
            
            // Use smaller steps for smooth mobile control
            const step = param.step * 0.5;
            param.value = Math.max(param.min, Math.min(param.max, param.value + delta * (param.max - param.min)));
            
            if (paramKey === 'kaleidoscope_segments') {
                param.value = Math.round(param.value / 2) * 2;
            }
            
            updateDisplay();
        }

        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            if (statusDiv) {
                statusDiv.className = type;
                statusDiv.textContent = message;
            }
        }

        function updateDisplay() {
            const paramKey = parameterKeys[currentParameterIndex];
            const param = parameters[paramKey];
            const palette = colorPalettes[currentPaletteIndex];
            
            const paramDiv = document.getElementById('currentParam');
            if (paramDiv) {
                paramDiv.textContent = `${param.name}: ${param.value.toFixed(3)} | ${palette.name}${invertColors ? ' (Inverted)' : ''}`;
            }
            
            // Update menu if visible
            updateMenuDisplay();
        }

        function adjustParameter(delta) {
            // Save current state before making changes
            saveStateForUndo();
            
            const paramKey = parameterKeys[currentParameterIndex];
            const param = parameters[paramKey];
            
            param.value = Math.max(param.min, Math.min(param.max, param.value + delta * param.step));
            
            if (paramKey === 'kaleidoscope_segments') {
                param.value = Math.round(param.value / 2) * 2;
            }
            
            updateDisplay();
            scheduleAutoSave();
        }

        function switchParameter(delta) {
            currentParameterIndex = (currentParameterIndex + delta + parameterKeys.length) % parameterKeys.length;
            updateDisplay();
        }

        function randomizeColors() {
            // Save current state before making changes
            saveStateForUndo();
            
            const palette = colorPalettes[currentPaletteIndex];
            for (let i = 0; i < 3; i++) {
                palette.a[i] = Math.random();
                palette.b[i] = Math.random();
                palette.c[i] = Math.random() * 2.0;
                palette.d[i] = Math.random();
            }
            
            if (currentPaletteIndex === 0) {
                currentPaletteIndex = 1;
                useColorPalette = true;
            }
            
            updateDisplay();
        }

        function resetToBlackWhite() {
            // Save current state before making changes
            saveStateForUndo();
            
            currentPaletteIndex = 0;
            useColorPalette = false;
            invertColors = false;
            updateDisplay();
        }

        function toggleInvertColors() {
            // Save current state before making changes
            saveStateForUndo();
            
            invertColors = !invertColors;
            updateDisplay();
        }

        function randomizeParameters() {
            // Save current state before making changes
            saveStateForUndo();
            
            const excludeParams = ['color_intensity', 'color_speed'];
            
            // Define reasonable randomization ranges (subset of full parameter ranges)
            const randomRanges = {
                fly_speed: { min: -1.0, max: 2.0 },
                contrast: { min: 0.5, max: 3.0 },
                kaleidoscope_segments: { min: 6.0, max: 32.0 },
                truchet_radius: { min: 0.1, max: 0.8 },
                center_fill_radius: { min: -0.5, max: 0.5 },
                layer_count: { min: 4, max: 8 },
                rotation_speed: { min: -2.0, max: 2.0 },
                zoom_level: { min: 0.1, max: 2.0 },
                plane_rotation_speed: { min: -2.0, max: 2.0 },
                camera_tilt_x: { min: -3.0, max: 3.0 },
                camera_tilt_y: { min: -3.0, max: 3.0 },
                camera_roll: { min: -1.0, max: 1.0 },
                path_stability: { min: -0.5, max: 1.0 },
                path_scale: { min: 0.5, max: 2.0 }
            };
            
            Object.keys(parameters).forEach(key => {
                if (excludeParams.includes(key)) return;
                
                const param = parameters[key];
                const range = randomRanges[key];
                
                if (range) {
                    // Use reasonable range for randomization
                    param.value = Math.random() * (range.max - range.min) + range.min;
                } else {
                    // Fallback to full range if not specified
                    param.value = Math.random() * (param.max - param.min) + param.min;
                }
                
                param.value = Math.round(param.value / param.step) * param.step;
                
                if (key === 'kaleidoscope_segments') {
                    param.value = Math.round(param.value / 2) * 2;
                }
                
                // Clamp to actual parameter bounds
                param.value = Math.max(param.min, Math.min(param.max, param.value));
            });
            
            updateDisplay();
            scheduleAutoSave();
        }

        function resetCurrentParameter() {
            // Save current state before making changes
            saveStateForUndo();
            
            const paramKey = parameterKeys[currentParameterIndex];
            const param = parameters[paramKey];
            
            const defaults = {
                fly_speed: 0.25, contrast: 1.0, kaleidoscope_segments: 10.0,
                truchet_radius: 0.35, center_fill_radius: 0.0, layer_count: 6,
                rotation_speed: 0.025, zoom_level: 0.3, color_intensity: 1.0,
                plane_rotation_speed: 0.5, camera_tilt_x: 0.0, camera_tilt_y: 0.0,
                camera_roll: 0.0, path_stability: 1.0, path_scale: 1.0, color_speed: 0.5
            };
            
            if (defaults[paramKey] !== undefined) {
                param.value = defaults[paramKey];
            }
            
            updateDisplay();
        }

        function resetAllParameters() {
            // Save current state before making changes
            saveStateForUndo();
            
            Object.keys(parameters).forEach(key => {
                const defaults = {
                    fly_speed: 0.25, contrast: 1.0, kaleidoscope_segments: 10.0,
                    truchet_radius: 0.35, center_fill_radius: 0.0, layer_count: 6,
                    rotation_speed: 0.025, zoom_level: 0.3, color_intensity: 1.0,
                    plane_rotation_speed: 0.5, camera_tilt_x: 0.0, camera_tilt_y: 0.0,
                    camera_roll: 0.0, path_stability: 1.0, path_scale: 1.0, color_speed: 0.5
                };
                
                if (defaults[key] !== undefined) {
                    parameters[key].value = defaults[key];
                }
            });
            
            currentPaletteIndex = 0;
            useColorPalette = false;
            invertColors = false;
            
            updateDisplay();
            updateMenuDisplay();
        }

        // Undo/Redo System Functions
        function saveStateForUndo() {
            // Create a snapshot of the current state
            const state = {
                parameters: {},
                currentPaletteIndex: currentPaletteIndex,
                useColorPalette: useColorPalette,
                invertColors: invertColors,
                palettes: JSON.parse(JSON.stringify(colorPalettes)) // Deep copy
            };
            
            // Copy parameter values
            Object.keys(parameters).forEach(key => {
                state.parameters[key] = parameters[key].value;
            });
            
            // Add to undo stack
            undoStack.push(state);
            
            // Limit stack size
            if (undoStack.length > maxUndoSteps) {
                undoStack.shift();
            }
            
            // Clear redo stack when new action is performed
            redoStack = [];
        }

        function undo() {
            if (undoStack.length === 0) {
                updateStatus('Nothing to undo', 'info');
                return;
            }
            
            // Save current state to redo stack
            const currentState = {
                parameters: {},
                currentPaletteIndex: currentPaletteIndex,
                useColorPalette: useColorPalette,
                invertColors: invertColors,
                palettes: JSON.parse(JSON.stringify(colorPalettes))
            };
            
            Object.keys(parameters).forEach(key => {
                currentState.parameters[key] = parameters[key].value;
            });
            
            redoStack.push(currentState);
            
            // Restore previous state
            const previousState = undoStack.pop();
            restoreState(previousState);
            
            updateStatus(`‚ü≤ Undone (${undoStack.length} steps remaining)`, 'success');
        }

        function redo() {
            if (redoStack.length === 0) {
                updateStatus('Nothing to redo', 'info');
                return;
            }
            
            // Save current state to undo stack
            const currentState = {
                parameters: {},
                currentPaletteIndex: currentPaletteIndex,
                useColorPalette: useColorPalette,
                invertColors: invertColors,
                palettes: JSON.parse(JSON.stringify(colorPalettes))
            };
            
            Object.keys(parameters).forEach(key => {
                currentState.parameters[key] = parameters[key].value;
            });
            
            undoStack.push(currentState);
            
            // Restore next state
            const nextState = redoStack.pop();
            restoreState(nextState);
            
            updateStatus(`‚ü≥ Redone (${redoStack.length} steps available)`, 'success');
        }

        function restoreState(state) {
            // Restore parameters
            Object.keys(state.parameters).forEach(key => {
                if (parameters[key]) {
                    parameters[key].value = state.parameters[key];
                }
            });
            
            // Restore color palette state
            currentPaletteIndex = state.currentPaletteIndex;
            useColorPalette = state.useColorPalette;
            invertColors = state.invertColors;
            
            // Restore palette data
            if (state.palettes) {
                state.palettes.forEach((palette, index) => {
                    if (colorPalettes[index]) {
                        colorPalettes[index] = { ...palette };
                    }
                });
            }
            
            updateDisplay();
            updateMenuDisplay();
        }

        function toggleMenu() {
            menuVisible = !menuVisible;
            const menu = document.getElementById('menu');
            const ui = document.getElementById('ui');
            const controls = document.getElementById('controls');
            
            if (menuVisible) {
                menu.classList.remove('hidden');
                ui.classList.add('hidden');
                controls.classList.add('hidden');
                updateMenuDisplay();
            } else {
                menu.classList.add('hidden');
                ui.classList.remove('hidden');
                controls.classList.remove('hidden');
            }
        }

        function updateMenuDisplay() {
            if (!menuVisible) return;
            
            // Update ALL parameters list with organized categories
            const allParamsList = document.getElementById('allParametersList');
            if (allParamsList) {
                let paramsHTML = '';
                
                // Add mobile instructions if on mobile
                if (isMobile) {
                    paramsHTML += '<div style="color: #4CAF50; font-weight: bold; margin-bottom: 10px; font-size: 14px;">üì± MOBILE CONTROLS</div>';
                    paramsHTML += '<div style="color: #FFC107; font-size: 12px; margin-bottom: 15px; line-height: 1.4;">';
                    paramsHTML += '‚Ä¢ Tap: Toggle menu<br>';
                    paramsHTML += '‚Ä¢ Double tap: Random colors<br>';
                    paramsHTML += '‚Ä¢ Hold: Reset ALL parameters<br>';
                    paramsHTML += '‚Ä¢ Quick swipe ‚Üê/‚Üí: Change parameter<br>';
                    paramsHTML += '‚Ä¢ Drag ‚Üê/‚Üí: Scroll through parameters<br>';
                    paramsHTML += '‚Ä¢ Swipe ‚Üë/‚Üì: Adjust value<br>';
                    paramsHTML += '‚Ä¢ Shake: Random all<br>';
                    paramsHTML += '</div>';
                }
                
                // Movement & Animation
                paramsHTML += '<div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">MOVEMENT & ANIMATION</div>';
                const movementParams = ['fly_speed', 'rotation_speed', 'plane_rotation_speed', 'zoom_level'];
                movementParams.forEach(key => {
                    const param = parameters[key];
                    const index = parameterKeys.indexOf(key);
                    const isCurrent = index === currentParameterIndex;
                    const style = isCurrent ? 'color: #4CAF50; font-weight: bold;' : 'color: #ffffff;';
                    const indicator = isCurrent && isMobile ? 'üëÜ ' : '';
                    paramsHTML += `<div style="${style}">${indicator}${param.name}: ${param.value.toFixed(3)}</div>`;
                });
                
                paramsHTML += '<br>';
                
                // Pattern & Visual
                paramsHTML += '<div style="color: #FFC107; font-weight: bold; margin-bottom: 5px;">PATTERN & VISUAL</div>';
                const patternParams = ['kaleidoscope_segments', 'truchet_radius', 'center_fill_radius', 'layer_count', 'contrast', 'color_intensity'];
                patternParams.forEach(key => {
                    const param = parameters[key];
                    const index = parameterKeys.indexOf(key);
                    const isCurrent = index === currentParameterIndex;
                    const style = isCurrent ? 'color: #4CAF50; font-weight: bold;' : 'color: #ffffff;';
                    const indicator = isCurrent && isMobile ? 'üëÜ ' : '';
                    const value = key === 'kaleidoscope_segments' || key === 'layer_count' ? 
                        param.value.toFixed(0) : param.value.toFixed(3);
                    paramsHTML += `<div style="${style}">${indicator}${param.name}: ${value}</div>`;
                });
                
                paramsHTML += '<br>';
                
                // Camera & Path
                paramsHTML += '<div style="color: #9C27B0; font-weight: bold; margin-bottom: 5px;">CAMERA & PATH</div>';
                const cameraParams = ['camera_tilt_x', 'camera_tilt_y', 'camera_roll', 'path_stability', 'path_scale'];
                cameraParams.forEach(key => {
                    const param = parameters[key];
                    const index = parameterKeys.indexOf(key);
                    const isCurrent = index === currentParameterIndex;
                    const style = isCurrent ? 'color: #4CAF50; font-weight: bold;' : 'color: #ffffff;';
                    const indicator = isCurrent && isMobile ? 'üëÜ ' : '';
                    paramsHTML += `<div style="${style}">${indicator}${param.name}: ${param.value.toFixed(3)}</div>`;
                });
                
                paramsHTML += '<br>';
                
                // Color & Animation Speed
                paramsHTML += '<div style="color: #FF5722; font-weight: bold; margin-bottom: 5px;">COLOR & SPEED</div>';
                const colorParams = ['color_speed'];
                colorParams.forEach(key => {
                    const param = parameters[key];
                    const index = parameterKeys.indexOf(key);
                    const isCurrent = index === currentParameterIndex;
                    const style = isCurrent ? 'color: #4CAF50; font-weight: bold;' : 'color: #ffffff;';
                    const indicator = isCurrent && isMobile ? 'üëÜ ' : '';
                    paramsHTML += `<div style="${style}">${indicator}${param.name}: ${param.value.toFixed(3)}</div>`;
                });
                
                allParamsList.innerHTML = paramsHTML;
            }
            
            // Only show right column on desktop
            const rightColumn = document.querySelector('.menu > div > div:nth-child(2)');
            if (rightColumn) {
                rightColumn.style.display = isMobile ? 'none' : 'block';
            }
            
            if (!isMobile) {
                // Update palettes list (desktop only)
                const allPalettesList = document.getElementById('allPalettesList');
                if (allPalettesList) {
                    let palettesHTML = '';
                    colorPalettes.forEach((palette, index) => {
                        const isCurrent = index === currentPaletteIndex;
                        const style = isCurrent ? 'color: #4CAF50; font-weight: bold;' : 'color: #ffffff;';
                        const inverted = isCurrent && invertColors ? ' (Inverted)' : '';
                        const active = isCurrent && useColorPalette ? ' ‚óè' : (isCurrent ? ' ‚óã' : '');
                        palettesHTML += `<div style="${style}">${palette.name}${inverted}${active}</div>`;
                    });
                    allPalettesList.innerHTML = palettesHTML;
                }
                
                // Update audio status (desktop only)
                const allAudioStatus = document.getElementById('allAudioStatus');
                if (allAudioStatus) {
                    if (microphoneActive) {
                        allAudioStatus.innerHTML = 'üé§ <span style="color: #4CAF50;">Microphone Active</span><br>üîä Audio Reactive: ON<br><em>Press M to stop</em>';
                    } else if (!audioElement) {
                        allAudioStatus.innerHTML = 'üéµ No audio file loaded<br>üé§ Microphone: OFF<br>üîä Audio Reactive: OFF<br><em>Press A for file, M for mic</em>';
                    } else {
                        const playStatus = audioPlaying ? '<span style="color: #4CAF50;">Playing</span>' : '<span style="color: #FF9800;">Paused</span>';
                        const reactiveStatus = audioReactive ? '<span style="color: #4CAF50;">ON</span>' : '<span style="color: #FF9800;">OFF</span>';
                        allAudioStatus.innerHTML = `üéµ File: ${playStatus}<br>üé§ Microphone: OFF<br>üîä Audio Reactive: ${reactiveStatus}<br><em>Press A to toggle, M for mic</em>`;
                    }
                }
            }
        }

        function saveParameters() {
            try {
                const saveData = {
                    parameters: {},
                    palette: {
                        currentPaletteIndex: currentPaletteIndex,
                        useColorPalette: useColorPalette,
                        invertColors: invertColors,
                        palettes: colorPalettes
                    },
                    timeAccumulation: timeAccumulation,
                    version: "1.0",
                    timestamp: new Date().toISOString(),
                    description: "Kaldao Fractal Visualizer Parameters"
                };
                
                // Save parameter values
                Object.keys(parameters).forEach(key => {
                    saveData.parameters[key] = parameters[key].value;
                });
                
                const jsonString = JSON.stringify(saveData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `kaldao-fractal-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                updateStatus('‚úÖ Parameters saved to file!', 'success');
                
            } catch (error) {
                updateStatus(`‚ùå Save failed: ${error.message}`, 'error');
            }
        }

        function loadParameters() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = function(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const saveData = JSON.parse(e.target.result);
                            
                            // Validate the save data
                            if (!saveData.parameters || !saveData.palette) {
                                throw new Error('Invalid save file format');
                            }
                            
                            // Load parameters
                            Object.keys(parameters).forEach(key => {
                                if (saveData.parameters[key] !== undefined) {
                                    parameters[key].value = saveData.parameters[key];
                                }
                            });
                            
                            // Load palette settings
                            if (saveData.palette.currentPaletteIndex !== undefined) {
                                currentPaletteIndex = saveData.palette.currentPaletteIndex;
                            }
                            if (saveData.palette.useColorPalette !== undefined) {
                                useColorPalette = saveData.palette.useColorPalette;
                            }
                            if (saveData.palette.invertColors !== undefined) {
                                invertColors = saveData.palette.invertColors;
                            }
                            if (saveData.palette.palettes) {
                                // Copy custom palette data
                                saveData.palette.palettes.forEach((palette, index) => {
                                    if (colorPalettes[index]) {
                                        colorPalettes[index] = { ...palette };
                                    }
                                });
                            }
                            
                            // Load time accumulation if present
                            if (saveData.timeAccumulation) {
                                Object.assign(timeAccumulation, saveData.timeAccumulation);
                            }
                            
                            updateDisplay();
                            updateMenuDisplay();
                            
                            const timestamp = saveData.timestamp ? 
                                new Date(saveData.timestamp).toLocaleString() : 'Unknown';
                            updateStatus(`‚úÖ Parameters loaded! (Saved: ${timestamp})`, 'success');
                            
                        } catch (error) {
                            updateStatus(`‚ùå Load failed: ${error.message}`, 'error');
                        }
                    };
                    
                    reader.readAsText(file);
                };
                
                input.click();
                
            } catch (error) {
                updateStatus(`‚ùå Load failed: ${error.message}`, 'error');
            }
        }

        async function toggleAudio() {
            if (!audioContext) {
                await initAudioContext();
            }
            
            if (!audioElement) {
                // Prompt user to upload audio file
                uploadAudioFile();
            } else {
                // Toggle audio playback and reactivity
                if (audioPlaying) {
                    audioElement.pause();
                    audioPlaying = false;
                    audioReactive = false;
                    restoreBaseParameters();
                    updateStatus('üéµ Audio paused', 'info');
                } else {
                    try {
                        // Resume audio context if needed
                        if (audioContext.state === 'suspended') {
                            await audioContext.resume();
                        }
                        
                        await audioElement.play();
                        audioPlaying = true;
                        audioReactive = true;
                        storeBaseParameters();
                        updateStatus('üéµ Audio playing with reactivity!', 'success');
                    } catch (error) {
                        updateStatus(`‚ùå Audio playback failed: ${error.message}`, 'error');
                    }
                }
                updateMenuDisplay();
            }
        }

        async function initAudioContext() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Resume context if suspended (required by some browsers)
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;
                audioData = new Uint8Array(analyser.frequencyBinCount);
                
                updateStatus('üéµ Audio system initialized', 'success');
            } catch (error) {
                updateStatus(`‚ùå Audio init failed: ${error.message}`, 'error');
            }
        }

        function uploadAudioFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'audio/*,.wav,.mp3,.ogg,.m4a,.aac';
            
            input.onchange = async function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                updateStatus(`üéµ Loading audio: ${file.name}...`, 'info');
                
                try {
                    // Clean up previous audio
                    if (audioElement) {
                        audioElement.pause();
                        audioElement.src = '';
                        audioElement = null;
                    }
                    
                    if (audioSource) {
                        audioSource.disconnect();
                        audioSource = null;
                    }
                    
                    // Create new audio element
                    audioElement = new Audio();
                    audioElement.preload = 'auto';
                    audioElement.loop = true;
                    
                    // Create object URL
                    const audioURL = URL.createObjectURL(file);
                    audioElement.src = audioURL;
                    
                    // Wait for audio to load
                    await new Promise((resolve, reject) => {
                        audioElement.oncanplaythrough = resolve;
                        audioElement.onerror = () => reject(new Error('Failed to decode audio file'));
                        audioElement.onabort = () => reject(new Error('Audio loading aborted'));
                        
                        // Timeout after 10 seconds
                        setTimeout(() => reject(new Error('Audio loading timeout')), 10000);
                    });
                    
                    // Resume audio context if needed
                    if (audioContext.state === 'suspended') {
                        await audioContext.resume();
                    }
                    
                    // Connect audio to analyser
                    audioSource = audioContext.createMediaElementSource(audioElement);
                    audioSource.connect(analyser);
                    audioSource.connect(audioContext.destination);
                    
                    updateStatus(`üéµ Audio loaded: ${file.name}`, 'success');
                    updateMenuDisplay();
                    
                    // Auto-start playback with reactivity
                    try {
                        await audioElement.play();
                        audioPlaying = true;
                        audioReactive = true;
                        storeBaseParameters();
                        updateStatus(`üéµ Playing: ${file.name} (Reactive mode)`, 'success');
                    } catch (playError) {
                        updateStatus(`‚ö†Ô∏è Audio loaded but autoplay blocked. Press A to play.`, 'info');
                    }
                    
                } catch (error) {
                    console.error('Audio loading error:', error);
                    updateStatus(`‚ùå Failed to load audio: ${error.message}`, 'error');
                    
                    // Clean up on error
                    if (audioElement) {
                        audioElement.src = '';
                        audioElement = null;
                    }
                    if (audioSource) {
                        audioSource.disconnect();
                        audioSource = null;
                    }
                }
            };
            
            input.click();
        }

        function storeBaseParameters() {
            // Store current parameter values as base values for audio reactivity
            // These remain unchanged by audio - only the modifiers change
            baseParameterValues = {};
            Object.keys(parameters).forEach(key => {
                baseParameterValues[key] = parameters[key].value;
            });
        }

        function restoreBaseParameters() {
            // This function is no longer needed since we use modifiers
            // But we'll keep it for backward compatibility
            updateDisplay();
        }

        function analyzeAudio() {
            if (!analyser || !audioData || !audioReactive || (!audioPlaying && !microphoneActive)) {
                return { bass: 0, mid: 0, treble: 0, overall: 0 };
            }
            
            analyser.getByteFrequencyData(audioData);
            
            // Frequency ranges (approximate for 44.1kHz sample rate)
            const bassRange = { start: 0, end: 32 };      // ~20-250Hz
            const midRange = { start: 32, end: 128 };     // ~250-2000Hz  
            const trebleRange = { start: 128, end: 256 }; // ~2000-8000Hz
            
            function getAverageVolume(range) {
                let sum = 0;
                for (let i = range.start; i < range.end && i < audioData.length; i++) {
                    sum += audioData[i];
                }
                return sum / (range.end - range.start) / 255.0;
            }
            
            const bass = getAverageVolume(bassRange);
            const mid = getAverageVolume(midRange);
            const treble = getAverageVolume(trebleRange);
            const overall = (bass + mid + treble) / 3.0;
            
            return { bass, mid, treble, overall };
        }

        function applyAudioReactivity() {
            if (!audioReactive || (!audioPlaying && !microphoneActive)) {
                // Reset all modifiers to 1.0 when not reactive
                Object.keys(audioModifiers).forEach(key => {
                    audioModifiers[key] = 1.0;
                });
                return;
            }
            
            const audioLevels = analyzeAudio();
            
            // Create dynamic multipliers based on audio
            const bassMultiplier = 1.0 + (audioLevels.bass * 0.8);      // 1.0 to 1.8x
            const midMultiplier = 1.0 + (audioLevels.mid * 0.4);        // 1.0 to 1.4x
            const trebleMultiplier = 1.0 + (audioLevels.treble * 0.3);  // 1.0 to 1.3x
            const overallMultiplier = 1.0 + (audioLevels.overall * 0.5); // 1.0 to 1.5x
            
            // Bass effects - make the center circle really pulse!
            audioModifiers.center_fill_radius = bassMultiplier * 1.5; // Extra bass sensitivity for center
            audioModifiers.truchet_radius = bassMultiplier;
            audioModifiers.zoom_level = 1.0 + (audioLevels.bass * 0.3); // Slight zoom pulse
            
            // Mid frequencies affect rotation and movement
            audioModifiers.rotation_speed = midMultiplier;
            audioModifiers.plane_rotation_speed = midMultiplier;
            audioModifiers.fly_speed = 1.0 + (audioLevels.mid * 0.6);
            
            // Treble affects visual complexity and color
            audioModifiers.kaleidoscope_segments = trebleMultiplier;
            audioModifiers.color_intensity = trebleMultiplier;
            audioModifiers.color_speed = trebleMultiplier;
            
            // Overall volume affects contrast and layer count
            audioModifiers.contrast = overallMultiplier;
            audioModifiers.layer_count = 1.0 + (audioLevels.overall * 0.3);
            
            // Path effects for more dynamic movement
            audioModifiers.path_scale = 1.0 + (audioLevels.overall * 0.4);
        }

        async function toggleMicrophone() {
            if (!audioContext) {
                await initAudioContext();
            }
            
            if (microphoneActive) {
                // Stop microphone
                stopMicrophone();
            } else {
                // Start microphone
                await startMicrophone();
            }
        }

        async function startMicrophone() {
            try {
                updateStatus('üé§ Requesting microphone access...', 'info');
                
                // Request microphone access
                microphoneStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });
                
                // Resume audio context if needed
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                // Stop any playing audio file
                if (audioElement && audioPlaying) {
                    audioElement.pause();
                    audioPlaying = false;
                }
                
                // Connect microphone to analyzer
                microphoneSource = audioContext.createMediaStreamSource(microphoneStream);
                microphoneSource.connect(analyser);
                
                microphoneActive = true;
                audioReactive = true;
                storeBaseParameters();
                
                updateStatus('üé§ Microphone active with reactivity!', 'success');
                updateMenuDisplay();
                
            } catch (error) {
                console.error('Microphone access error:', error);
                let errorMessage = 'Failed to access microphone';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'Microphone access denied. Please allow microphone access and try again.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'No microphone found. Please connect a microphone and try again.';
                } else if (error.name === 'NotReadableError') {
                    errorMessage = 'Microphone is busy or not available.';
                }
                
                updateStatus(`‚ùå ${errorMessage}`, 'error');
                microphoneActive = false;
            }
        }

        function stopMicrophone() {
            try {
                // Stop microphone stream
                if (microphoneStream) {
                    microphoneStream.getTracks().forEach(track => track.stop());
                    microphoneStream = null;
                }
                
                // Disconnect microphone source
                if (microphoneSource) {
                    microphoneSource.disconnect();
                    microphoneSource = null;
                }
                
                microphoneActive = false;
                audioReactive = false;
                restoreBaseParameters();
                
                updateStatus('üé§ Microphone stopped', 'info');
                updateMenuDisplay();
                
            } catch (error) {
                console.error('Error stopping microphone:', error);
                updateStatus('‚ùå Error stopping microphone', 'error');
            }
        }

        // State persistence functions
        function scheduleAutoSave() {
            // Clear existing timeout
            if (autoSaveTimeout) {
                clearTimeout(autoSaveTimeout);
            }
            
            // Schedule auto-save after delay
            autoSaveTimeout = setTimeout(() => {
                saveStateToStorage();
            }, AUTO_SAVE_DELAY);
        }
        
        function saveStateToStorage() {
            try {
                const state = {
                    parameters: {},
                    currentParameterIndex: currentParameterIndex,
                    currentPaletteIndex: currentPaletteIndex,
                    useColorPalette: useColorPalette,
                    invertColors: invertColors,
                    palettes: JSON.parse(JSON.stringify(colorPalettes)),
                    timeAccumulation: { ...timeAccumulation },
                    version: "1.0",
                    timestamp: Date.now()
                };
                
                // Save parameter values
                Object.keys(parameters).forEach(key => {
                    state.parameters[key] = parameters[key].value;
                });
                
                localStorage.setItem('kaldao23_state', JSON.stringify(state));
                
                if (isMobile) {
                    console.log('üì± State auto-saved to localStorage');
                }
            } catch (error) {
                console.error('Failed to save state to localStorage:', error);
            }
        }
        
        function loadStateFromStorage() {
            try {
                const savedState = localStorage.getItem('kaldao23_state');
                if (!savedState) {
                    stateLoaded = true;
                    return;
                }
                
                const state = JSON.parse(savedState);
                
                // Validate state version
                if (!state.version || state.version !== "1.0") {
                    console.log('State version mismatch, using defaults');
                    stateLoaded = true;
                    return;
                }
                
                // Load parameters
                if (state.parameters) {
                    Object.keys(parameters).forEach(key => {
                        if (state.parameters[key] !== undefined) {
                            parameters[key].value = state.parameters[key];
                        }
                    });
                }
                
                // Load UI state
                if (state.currentParameterIndex !== undefined) {
                    currentParameterIndex = Math.max(0, Math.min(parameterKeys.length - 1, state.currentParameterIndex));
                }
                if (state.currentPaletteIndex !== undefined) {
                    currentPaletteIndex = Math.max(0, Math.min(colorPalettes.length - 1, state.currentPaletteIndex));
                }
                if (state.useColorPalette !== undefined) {
                    useColorPalette = state.useColorPalette;
                }
                if (state.invertColors !== undefined) {
                    invertColors = state.invertColors;
                }
                
                // Load custom palettes
                if (state.palettes && Array.isArray(state.palettes)) {
                    state.palettes.forEach((palette, index) => {
                        if (colorPalettes[index] && palette.a && palette.b && palette.c && palette.d) {
                            colorPalettes[index] = { ...palette };
                        }
                    });
                }
                
                // Load time accumulation
                if (state.timeAccumulation) {
                    Object.assign(timeAccumulation, state.timeAccumulation);
                }
                
                stateLoaded = true;
                
                if (isMobile) {
                    const ageMinutes = Math.floor((Date.now() - (state.timestamp || 0)) / 60000);
                    console.log(`üì± State loaded from localStorage (${ageMinutes}m old)`);
                }
                
            } catch (error) {
                console.error('Failed to load state from localStorage:', error);
                stateLoaded = true;
            }
        }
        
        // Clear saved state (for debugging)
        function clearSavedState() {
            try {
                localStorage.removeItem('kaldao23_state');
                console.log('üì± Saved state cleared');
            } catch (error) {
                console.error('Failed to clear saved state:', error);
            }
        }

        function render() {
            try {
                const deltaTime = 1.0 / 60.0;

                // Apply audio reactivity to update modifiers
                applyAudioReactivity();

                if (!animationPaused) {
                    timeAccumulation.camera_position += parameters.fly_speed.value * audioModifiers.fly_speed * deltaTime;
                    timeAccumulation.rotation_time += parameters.rotation_speed.value * audioModifiers.rotation_speed * deltaTime;
                    timeAccumulation.plane_rotation_time += parameters.plane_rotation_speed.value * audioModifiers.plane_rotation_speed * deltaTime;
                    timeAccumulation.color_time += parameters.color_speed.value * audioModifiers.color_speed * deltaTime;
                }

                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.useProgram(program);
                
                // Set all uniforms using base parameters multiplied by audio modifiers
                gl.uniform2f(uniforms.u_resolution, canvas.width, canvas.height);
                gl.uniform1f(uniforms.u_time, performance.now() * 0.001);
                gl.uniform1f(uniforms.u_camera_position, timeAccumulation.camera_position);
                gl.uniform1f(uniforms.u_rotation_time, timeAccumulation.rotation_time);
                gl.uniform1f(uniforms.u_plane_rotation_time, timeAccumulation.plane_rotation_time);
                gl.uniform1f(uniforms.u_color_time, timeAccumulation.color_time);
                
                // Apply audio modifiers to parameters
                gl.uniform1f(uniforms.u_fly_speed, parameters.fly_speed.value * audioModifiers.fly_speed);
                gl.uniform1f(uniforms.u_contrast, parameters.contrast.value * audioModifiers.contrast);
                gl.uniform1f(uniforms.u_kaleidoscope_segments, parameters.kaleidoscope_segments.value * audioModifiers.kaleidoscope_segments);
                gl.uniform1f(uniforms.u_layer_count, Math.max(1, Math.min(10, parameters.layer_count.value * audioModifiers.layer_count)));
                gl.uniform1f(uniforms.u_truchet_radius, parameters.truchet_radius.value * audioModifiers.truchet_radius);
                gl.uniform1f(uniforms.u_center_fill_radius, parameters.center_fill_radius.value * audioModifiers.center_fill_radius);
                gl.uniform1f(uniforms.u_rotation_speed, parameters.rotation_speed.value * audioModifiers.rotation_speed);
                gl.uniform1f(uniforms.u_plane_rotation_speed, parameters.plane_rotation_speed.value * audioModifiers.plane_rotation_speed);
                gl.uniform1f(uniforms.u_zoom_level, parameters.zoom_level.value * audioModifiers.zoom_level);
                gl.uniform1f(uniforms.u_color_intensity, parameters.color_intensity.value * audioModifiers.color_intensity);
                gl.uniform1f(uniforms.u_camera_tilt_x, parameters.camera_tilt_x.value * audioModifiers.camera_tilt_x);
                gl.uniform1f(uniforms.u_camera_tilt_y, parameters.camera_tilt_y.value * audioModifiers.camera_tilt_y);
                gl.uniform1f(uniforms.u_camera_roll, parameters.camera_roll.value * audioModifiers.camera_roll);
                gl.uniform1f(uniforms.u_path_stability, parameters.path_stability.value * audioModifiers.path_stability);
                gl.uniform1f(uniforms.u_path_scale, parameters.path_scale.value * audioModifiers.path_scale);
                gl.uniform1f(uniforms.u_color_speed, parameters.color_speed.value * audioModifiers.color_speed);
                gl.uniform1f(uniforms.u_use_color_palette, useColorPalette ? 1.0 : 0.0);
                gl.uniform1f(uniforms.u_invert_colors, invertColors ? 1.0 : 0.0);
                
                const palette = colorPalettes[currentPaletteIndex];
                gl.uniform3f(uniforms.u_palette_a, palette.a[0], palette.a[1], palette.a[2]);
                gl.uniform3f(uniforms.u_palette_b, palette.b[0], palette.b[1], palette.b[2]);
                gl.uniform3f(uniforms.u_palette_c, palette.c[0], palette.c[1], palette.c[2]);
                gl.uniform3f(uniforms.u_palette_d, palette.d[0], palette.d[1], palette.d[2]);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                requestAnimationFrame(render);
            } catch (error) {
                updateStatus(`Render error: ${error.message}`, 'error');
            }
        }

        // Initialize when page loads
        window.addEventListener('load', init);
        
        // Save state before page unload (mobile browsers)
        window.addEventListener('beforeunload', () => {
            if (stateLoaded) {
                saveStateToStorage();
            }
        });
        
        // Save state when page becomes hidden (mobile browsers)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && stateLoaded) {
                saveStateToStorage();
            }
        });
        
        // Save state on page focus loss (mobile browsers)
        window.addEventListener('blur', () => {
            if (stateLoaded) {
                saveStateToStorage();
            }
        });
    </script>
</body>
</html>
